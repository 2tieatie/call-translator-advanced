"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/utils/utils.ts":
/*!****************************!*\
  !*** ./app/utils/utils.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addVideoElement: function() { return /* binding */ addVideoElement; },\n/* harmony export */   copyToClipboard: function() { return /* binding */ copyToClipboard; },\n/* harmony export */   createRoom: function() { return /* binding */ createRoom; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   dragAndDrop: function() { return /* binding */ dragAndDrop; },\n/* harmony export */   generateAndSavePermanentId: function() { return /* binding */ generateAndSavePermanentId; },\n/* harmony export */   getLanguagesArray: function() { return /* binding */ getLanguagesArray; },\n/* harmony export */   getVideoObj: function() { return /* binding */ getVideoObj; },\n/* harmony export */   handleVideoMute: function() { return /* binding */ handleVideoMute; },\n/* harmony export */   makeVideoElement: function() { return /* binding */ makeVideoElement; },\n/* harmony export */   removeVideoElement: function() { return /* binding */ removeVideoElement; },\n/* harmony export */   setAudioMuteState: function() { return /* binding */ setAudioMuteState; },\n/* harmony export */   setVideoMuteState: function() { return /* binding */ setVideoMuteState; },\n/* harmony export */   startLocalVideo: function() { return /* binding */ startLocalVideo; }\n/* harmony export */ });\n/* harmony import */ var _utils_socketNetworkHandlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/socketNetworkHandlers */ \"(app-pages-browser)/./app/utils/socketNetworkHandlers.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst serverURL = \"http://127.0.0.1:5000/\";\nconst createRoom = async (roomName)=>{\n    try {\n        const response = await fetch(\"\".concat(serverURL, \"create_room\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"room_name\": roomName\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to create room\");\n        }\n        const data = await response.json();\n        const roomId = data.room_id;\n        const createdRoomName = data.room_name;\n        return {\n            roomId,\n            roomName: createdRoomName\n        };\n    } catch (error) {\n        console.error(\"Error creating room:\", error);\n        return null;\n    }\n};\nconst getLanguagesArray = async ()=>{\n    const response = await fetch(\"\".concat(serverURL, \"/languages\"), {\n        method: \"GET\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to load languages list\");\n    }\n    const data = await response.json();\n    return data.names.map((obj)=>Object.keys(obj)[0]);\n};\nconst decode = (value)=>{\n    if (Array.isArray(value)) {\n        return \"\";\n    }\n    return value ? decodeURIComponent(value) : \"\";\n};\nfunction makeVideoElement(elementId, displayName) {\n    const wrapperDiv = document.createElement(\"div\");\n    const vidWrapper = document.createElement(\"div\");\n    const vid = document.createElement(\"video\");\n    const nameText = document.createElement(\"h1\");\n    wrapperDiv.id = \"div_\".concat(elementId);\n    vid.id = \"vid_\".concat(elementId);\n    vid.className = \"remoteVideo rounded-lg shadow-md border border-gray-300 transition-shadow duration-500 ease-in-out\";\n    wrapperDiv.className = \"remoteVideo video-item\";\n    vidWrapper.className = \"vid-wrapper\";\n    vidWrapper.id = \"vidwr_\".concat(elementId);\n    nameText.className = \"display-name\";\n    wrapperDiv.style.backgroundColor = \"rgba(102, 177, 244, 0)\";\n    vidWrapper.style.backgroundColor = \"rgba(255, 255, 255, 0)\";\n    vid.autoplay = true;\n    nameText.innerText = displayName;\n    vidWrapper.appendChild(vid);\n    wrapperDiv.appendChild(vidWrapper);\n    wrapperDiv.appendChild(nameText);\n    return wrapperDiv;\n}\nfunction addVideoElement(elementId, displayName) {\n    removeVideoElement(elementId);\n    const videoGrid = document.getElementById(\"video_grid\");\n    if (videoGrid) {\n        videoGrid.appendChild(makeVideoElement(elementId, displayName));\n    // getParticipantsWithOtherLanguages();\n    } else {\n        console.log(\"No Video Grid\");\n    }\n}\nfunction removeVideoElement(elementId) {\n    const div = document.getElementById(\"div_\".concat(elementId));\n    if (!div) {\n        console.log(\"Video element not found\");\n        return;\n    }\n    const vid = getVideoObj(elementId);\n    if (vid) {\n        if (vid.srcObject) {\n            const tracks = vid.srcObject.getTracks();\n            tracks.forEach((track)=>track.stop());\n        }\n        vid.removeAttribute(\"srcObject\");\n        vid.removeAttribute(\"src\");\n    }\n    div.remove();\n}\nfunction getVideoObj(elementId) {\n    const videoObj = document.getElementById(\"vid_\".concat(elementId));\n    if (videoObj) {\n        return videoObj;\n    }\n    console.log(\"No videoObj vid_\" + elementId);\n    return null;\n}\nconst dragAndDrop = (element)=>{\n    const elementContainer = element.current;\n    if (elementContainer) {\n        let isDragging = false;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragStartLeft = 0;\n        let dragStartTop = 0;\n        const handleDragStart = (event)=>{\n            isDragging = true;\n            dragStartX = event.clientX;\n            dragStartY = event.clientY;\n            dragStartLeft = elementContainer.offsetLeft;\n            dragStartTop = elementContainer.offsetTop;\n        };\n        const handleDragMove = (event)=>{\n            if (!isDragging) return;\n            const deltaX = event.clientX - dragStartX;\n            const deltaY = event.clientY - dragStartY;\n            elementContainer.style.left = \"\".concat(dragStartLeft + deltaX, \"px\");\n            elementContainer.style.top = \"\".concat(dragStartTop + deltaY, \"px\");\n        };\n        const handleDragEnd = ()=>{\n            isDragging = false;\n        };\n        elementContainer.addEventListener(\"mousedown\", handleDragStart);\n        document.addEventListener(\"mousemove\", handleDragMove);\n        document.addEventListener(\"mouseup\", handleDragEnd);\n        return ()=>{\n            elementContainer.removeEventListener(\"mousedown\", handleDragStart);\n            document.removeEventListener(\"mousemove\", handleDragMove);\n            document.removeEventListener(\"mouseup\", handleDragEnd);\n        };\n    }\n};\nconst setAudioMuteState = (stream, muted)=>{\n    console.log(stream);\n    if (stream) {\n        if (\"getAudioTracks\" in stream) {\n            stream.getAudioTracks().forEach((track)=>{\n                track.enabled = !muted;\n                console.log(track.enabled);\n            });\n        }\n    }\n    return stream;\n};\nfunction stopVideoOnly(stream) {\n    stream.getVideoTracks().forEach((track)=>{\n        track.enabled = false;\n        setTimeout(()=>{\n            track.stop();\n            console.log(track);\n        }, 1);\n    });\n}\nfunction setVideoMuteState(videoRef, muted) {\n    let localStream = videoRef.srcObject;\n    if (!muted) {\n        console.log(123123);\n        stopVideoOnly(localStream);\n    } else {\n        navigator.mediaDevices.getUserMedia({\n            video: true\n        }).then((stream)=>{\n            videoRef.srcObject = stream;\n            (0,_utils_socketNetworkHandlers__WEBPACK_IMPORTED_MODULE_0__.updateRemotePeerConnections)(stream);\n        }).catch((error)=>{\n            console.error(\"Error accessing camera\", error);\n        });\n    }\n}\nlet uuidv4 = ()=>{\n    return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, (c)=>(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n};\nconst generateAndSavePermanentId = ()=>{\n    const permanentId = localStorage.getItem(\"permanent_id\");\n    if (permanentId) {\n        console.log(\"Permanent ID already exists:\", permanentId);\n        return permanentId;\n    } else {\n        const newPermanentId = uuidv4();\n        localStorage.setItem(\"permanent_id\", newPermanentId);\n        console.log(\"New Permanent ID generated:\", newPermanentId);\n        return newPermanentId;\n    }\n};\nconst startLocalVideo = async (videoRef)=>{\n    try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n            video: true,\n            audio: true\n        });\n        if (videoRef.current) {\n            videoRef.current.srcObject = stream;\n            await new Promise((resolve)=>{\n                videoRef.current.onloadedmetadata = ()=>{\n                    resolve();\n                };\n            });\n        }\n    } catch (error) {\n        console.error(\"Error accessing media devices:\", error);\n    }\n};\nconst handleVideoMute = (videoMuted, videoRef)=>{\n    if (!videoMuted && videoRef.current && videoRef.current.srcObject instanceof MediaStream) {\n        const videoTracks = videoRef.current.srcObject.getVideoTracks();\n        videoTracks.forEach((track)=>{\n            track.enabled = false;\n            setTimeout(()=>{\n                track.stop();\n            }, 500);\n        });\n    } else {\n        startLocalVideo(videoRef).then(()=>{\n            setTimeout(()=>{\n                if (videoRef.current && videoRef.current.srcObject instanceof MediaStream) {\n                    (0,_utils_socketNetworkHandlers__WEBPACK_IMPORTED_MODULE_0__.updateRemotePeerConnections)(videoRef.current.srcObject);\n                }\n            }, 500);\n        });\n    }\n};\nasync function copyToClipboard(value) {\n    try {\n        await navigator.clipboard.writeText(value);\n    } catch (err) {\n        console.error(\"Error occurred:\", err);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy91dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRTtBQUNoRDtBQUUxQixNQUFNRSxZQUFZO0FBRVgsTUFBTUMsYUFBYSxPQUFPQztJQUMvQixJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWEsT0FBVkosV0FBVSxnQkFBYztZQUN0REssUUFBUTtZQUNSQyxTQUFTO2dCQUNQLGdCQUFnQjtnQkFDaEIsYUFBYUo7WUFDZjtRQUNGO1FBRUEsSUFBSSxDQUFDQyxTQUFTSSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsT0FBTyxNQUFNTixTQUFTTyxJQUFJO1FBQ2hDLE1BQU1DLFNBQVNGLEtBQUtHLE9BQU87UUFDM0IsTUFBTUMsa0JBQWtCSixLQUFLSyxTQUFTO1FBQ3RDLE9BQU87WUFBRUg7WUFBUVQsVUFBVVc7UUFBZ0I7SUFDN0MsRUFBRSxPQUFPRSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3RDLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFHSyxNQUFNRSxvQkFBb0I7SUFDN0IsTUFBTWQsV0FBVyxNQUFNQyxNQUFNLEdBQWEsT0FBVkosV0FBVSxlQUFhO1FBQ3JESyxRQUFRO1FBQ1JDLFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7SUFBQztJQUNILElBQUksQ0FBQ0gsU0FBU0ksRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLE1BQU1DLE9BQU8sTUFBTU4sU0FBU08sSUFBSTtJQUNoQyxPQUFPRCxLQUFLUyxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxNQUFZQyxPQUFPQyxJQUFJLENBQUNGLElBQUksQ0FBQyxFQUFFO0FBQzFELEVBQUM7QUFFTSxNQUFNRyxTQUFTLENBQUNDO0lBQ3JCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN4QixPQUFPO0lB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RCxLQUFLLENBQUMsa0NBQWtDQTtJQUNsRDtBQUNGLEVBQUU7QUFDSyxNQUFNdUcsa0JBQWtCLENBQUNDLFlBQXFCM0I7SUFDbkQsSUFBSSxDQUFDMkIsY0FBYzNCLFNBQVM3QixPQUFPLElBQUk2QixTQUFTN0IsT0FBTyxDQUFDWixTQUFTLFlBQVlxRSxhQUFhO1FBQ3RGLE1BQU1DLGNBQWM3QixTQUFTN0IsT0FBTyxDQUFDWixTQUFTLENBQUNzQyxjQUFjO1FBQzdEZ0MsWUFBWW5FLE9BQU8sQ0FBQyxDQUFDQztZQUNuQkEsTUFBTWdDLE9BQU8sR0FBRztZQUNoQkcsV0FBWTtnQkFDVm5DLE1BQU1DLElBQUk7WUFDWixHQUFHO1FBQ0w7SUFDRixPQUNLO1FBQ0h5RCxnQkFBZ0JyQixVQUFVTSxJQUFJLENBQUU7WUFDOUJSLFdBQVc7Z0JBQ1AsSUFBSUUsU0FBUzdCLE9BQU8sSUFBSTZCLFNBQVM3QixPQUFPLENBQUNaLFNBQVMsWUFBWXFFLGFBQWE7b0JBQ3pFMUgseUZBQTJCQSxDQUFDOEYsU0FBUzdCLE9BQU8sQ0FBQ1osU0FBUztnQkFDeEQ7WUFDRixHQUFHO1FBQ0w7SUFFSjtBQUNKLEVBQUM7QUFFTSxlQUFldUUsZ0JBQWdCbEcsS0FBYTtJQUNqRCxJQUFJO1FBQ0YsTUFBTXNFLFVBQVU2QixTQUFTLENBQUNDLFNBQVMsQ0FBQ3BHO0lBQ3RDLEVBQUUsT0FBT3FHLEtBQUs7UUFDWjdHLFFBQVFELEtBQUssQ0FBQyxtQkFBbUI4RztJQUNuQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC91dGlscy91dGlscy50cz82OWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXBkYXRlUmVtb3RlUGVlckNvbm5lY3Rpb25zfSBmcm9tIFwiQC91dGlscy9zb2NrZXROZXR3b3JrSGFuZGxlcnNcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuY29uc3Qgc2VydmVyVVJMID0gJ2h0dHA6Ly8xMjcuMC4wLjE6NTAwMC8nXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb29tID0gYXN5bmMgKHJvb21OYW1lOiBzdHJpbmcpOiBQcm9taXNlPHsgcm9vbUlkOiBzdHJpbmc7IHJvb21OYW1lOiBzdHJpbmcgfSB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3NlcnZlclVSTH1jcmVhdGVfcm9vbWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAncm9vbV9uYW1lJzogcm9vbU5hbWUsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHJvb20nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IHJvb21JZCA9IGRhdGEucm9vbV9pZDtcbiAgICBjb25zdCBjcmVhdGVkUm9vbU5hbWUgPSBkYXRhLnJvb21fbmFtZTtcbiAgICByZXR1cm4geyByb29tSWQsIHJvb21OYW1lOiBjcmVhdGVkUm9vbU5hbWUgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG5leHBvcnQgY29uc3QgZ2V0TGFuZ3VhZ2VzQXJyYXkgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVUkx9L2xhbmd1YWdlc2AsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9fSlcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGxhbmd1YWdlcyBsaXN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS5uYW1lcy5tYXAoKG9iajoge30pID0+IE9iamVjdC5rZXlzKG9iailbMF0pXG59XG5cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAodmFsdWU6IHN0cmluZyB8IG51bGwgfCBzdHJpbmdbXSkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6ICcnO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VWaWRlb0VsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcsIGRpc3BsYXlOYW1lOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB7XG4gIGNvbnN0IHdyYXBwZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCB2aWRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3QgdmlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICBjb25zdCBuYW1lVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcblxuICB3cmFwcGVyRGl2LmlkID0gYGRpdl8ke2VsZW1lbnRJZH1gO1xuICB2aWQuaWQgPSBgdmlkXyR7ZWxlbWVudElkfWA7XG4gIHZpZC5jbGFzc05hbWUgPSBcInJlbW90ZVZpZGVvIHJvdW5kZWQtbGcgc2hhZG93LW1kIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdHJhbnNpdGlvbi1zaGFkb3cgZHVyYXRpb24tNTAwIGVhc2UtaW4tb3V0XCI7XG4gIHdyYXBwZXJEaXYuY2xhc3NOYW1lID0gXCJyZW1vdGVWaWRlbyB2aWRlby1pdGVtXCI7XG4gIHZpZFdyYXBwZXIuY2xhc3NOYW1lID0gXCJ2aWQtd3JhcHBlclwiO1xuICB2aWRXcmFwcGVyLmlkID0gYHZpZHdyXyR7ZWxlbWVudElkfWA7XG4gIG5hbWVUZXh0LmNsYXNzTmFtZSA9IFwiZGlzcGxheS1uYW1lXCI7XG4gIHdyYXBwZXJEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDEwMiwgMTc3LCAyNDQsIDApXCI7XG4gIHZpZFdyYXBwZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCI7XG4gIHZpZC5hdXRvcGxheSA9IHRydWU7XG4gIG5hbWVUZXh0LmlubmVyVGV4dCA9IGRpc3BsYXlOYW1lO1xuXG4gIHZpZFdyYXBwZXIuYXBwZW5kQ2hpbGQodmlkKTtcbiAgd3JhcHBlckRpdi5hcHBlbmRDaGlsZCh2aWRXcmFwcGVyKTtcbiAgd3JhcHBlckRpdi5hcHBlbmRDaGlsZChuYW1lVGV4dCk7XG5cbiAgcmV0dXJuIHdyYXBwZXJEaXY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRWaWRlb0VsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcsIGRpc3BsYXlOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgcmVtb3ZlVmlkZW9FbGVtZW50KGVsZW1lbnRJZCk7XG4gIGNvbnN0IHZpZGVvR3JpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW9fZ3JpZFwiKTtcbiAgaWYgKHZpZGVvR3JpZCkge1xuICAgIHZpZGVvR3JpZC5hcHBlbmRDaGlsZChtYWtlVmlkZW9FbGVtZW50KGVsZW1lbnRJZCwgZGlzcGxheU5hbWUpKTtcbiAgICAvLyBnZXRQYXJ0aWNpcGFudHNXaXRoT3RoZXJMYW5ndWFnZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnTm8gVmlkZW8gR3JpZCcpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZpZGVvRWxlbWVudChlbGVtZW50SWQ6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgZGl2XyR7ZWxlbWVudElkfWApO1xuICBpZiAoIWRpdikge1xuICAgIGNvbnNvbGUubG9nKFwiVmlkZW8gZWxlbWVudCBub3QgZm91bmRcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdmlkID0gZ2V0VmlkZW9PYmooZWxlbWVudElkKTtcbiAgaWYgKHZpZCkge1xuICAgIGlmICh2aWQuc3JjT2JqZWN0KSB7XG4gICAgICBjb25zdCB0cmFja3MgPSAodmlkLnNyY09iamVjdCBhcyBNZWRpYVN0cmVhbSkuZ2V0VHJhY2tzKCk7XG4gICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgfVxuICAgIHZpZC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNPYmplY3RcIik7XG4gICAgdmlkLnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfVxuXG4gIGRpdi5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZGVvT2JqKGVsZW1lbnRJZDogc3RyaW5nKTogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwge1xuICBjb25zdCB2aWRlb09iaiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGB2aWRfJHtlbGVtZW50SWR9YCkgYXMgSFRNTFZpZGVvRWxlbWVudCB8IG51bGw7XG4gIGlmICh2aWRlb09iaikge1xuICAgIHJldHVybiB2aWRlb09ialxuICB9XG4gIGNvbnNvbGUubG9nKCdObyB2aWRlb09iaiB2aWRfJyArIGVsZW1lbnRJZClcbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGRyYWdBbmREcm9wID0gKGVsZW1lbnQ6IGFueSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRDb250YWluZXIgPSBlbGVtZW50LmN1cnJlbnQ7XG4gICAgaWYgKGVsZW1lbnRDb250YWluZXIpIHtcbiAgICAgIGxldCBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICBsZXQgZHJhZ1N0YXJ0WCA9IDA7XG4gICAgICBsZXQgZHJhZ1N0YXJ0WSA9IDA7XG4gICAgICBsZXQgZHJhZ1N0YXJ0TGVmdCA9IDA7XG4gICAgICBsZXQgZHJhZ1N0YXJ0VG9wID0gMDtcblxuICAgICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICBkcmFnU3RhcnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgZHJhZ1N0YXJ0WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGRyYWdTdGFydExlZnQgPSBlbGVtZW50Q29udGFpbmVyLm9mZnNldExlZnQ7XG4gICAgICAgIGRyYWdTdGFydFRvcCA9IGVsZW1lbnRDb250YWluZXIub2Zmc2V0VG9wO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgaGFuZGxlRHJhZ01vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LmNsaWVudFggLSBkcmFnU3RhcnRYO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gZHJhZ1N0YXJ0WTtcbiAgICAgICAgZWxlbWVudENvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7ZHJhZ1N0YXJ0TGVmdCArIGRlbHRhWH1weGA7XG4gICAgICAgIGVsZW1lbnRDb250YWluZXIuc3R5bGUudG9wID0gYCR7ZHJhZ1N0YXJ0VG9wICsgZGVsdGFZfXB4YDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGhhbmRsZURyYWdFbmQgPSAoKSA9PiB7XG4gICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZURyYWdNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVEcmFnRW5kKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZWxlbWVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVEcmFnTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVEcmFnRW5kKTtcbiAgICAgIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjb25zdCBzZXRBdWRpb011dGVTdGF0ZSA9IChzdHJlYW06IE1lZGlhUHJvdmlkZXIgfCBudWxsLCBtdXRlZDogYm9vbGVhbik6IE1lZGlhUHJvdmlkZXIgfCBudWxsID0+IHtcbiAgY29uc29sZS5sb2coc3RyZWFtKVxuICBpZiAoc3RyZWFtKSB7XG4gICAgaWYgKFwiZ2V0QXVkaW9UcmFja3NcIiBpbiBzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYWNrLmVuYWJsZWQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmVhbTtcbn07XG5cbmZ1bmN0aW9uIHN0b3BWaWRlb09ubHkoc3RyZWFtOiB7IGdldFZpZGVvVHJhY2tzOiAoKSA9PiBhbnlbXTsgfSkge1xuICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0cmFjaylcbiAgICAgICAgfSwgMSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRWaWRlb011dGVTdGF0ZSh2aWRlb1JlZjogYW55LCBtdXRlZDogYW55KSB7XG4gICAgbGV0IGxvY2FsU3RyZWFtID0gdmlkZW9SZWYuc3JjT2JqZWN0XG4gICAgaWYgKCFtdXRlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygxMjMxMjMpXG4gICAgICAgIHN0b3BWaWRlb09ubHkobG9jYWxTdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSlcbiAgICAgICAgICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICAgICAgdmlkZW9SZWYuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbW90ZVBlZXJDb25uZWN0aW9ucyhzdHJlYW0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIGNhbWVyYVwiLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cbmxldCB1dWlkdjQgPSAoKSA9PiB7XG4gIHJldHVybiBcIjEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMFwiLnJlcGxhY2UoL1swMThdL2csIGMgPT5cbiAgICAoYyBeIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdICYgMTUgPj4gYyAvIDQpLnRvU3RyaW5nKDE2KVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVBbmRTYXZlUGVybWFuZW50SWQgPSAoKSA9PiB7XG4gIGNvbnN0IHBlcm1hbmVudElkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Blcm1hbmVudF9pZCcpO1xuXG4gIGlmIChwZXJtYW5lbnRJZCkge1xuICAgIGNvbnNvbGUubG9nKCdQZXJtYW5lbnQgSUQgYWxyZWFkeSBleGlzdHM6JywgcGVybWFuZW50SWQpO1xuICAgIHJldHVybiBwZXJtYW5lbnRJZFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld1Blcm1hbmVudElkID0gdXVpZHY0KCk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Blcm1hbmVudF9pZCcsIG5ld1Blcm1hbmVudElkKTtcbiAgICBjb25zb2xlLmxvZygnTmV3IFBlcm1hbmVudCBJRCBnZW5lcmF0ZWQ6JywgbmV3UGVybWFuZW50SWQpO1xuICAgIHJldHVybiBuZXdQZXJtYW5lbnRJZFxuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc3RhcnRMb2NhbFZpZGVvID0gYXN5bmMgKHZpZGVvUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTFZpZGVvRWxlbWVudD4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhdWRpbzogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICB2aWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQhLm9ubG9hZGVkbWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBtZWRpYSBkZXZpY2VzOicsIGVycm9yKTtcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBoYW5kbGVWaWRlb011dGUgPSAodmlkZW9NdXRlZDogYm9vbGVhbiwgdmlkZW9SZWY6IGFueSkgPT4ge1xuICBpZiAoIXZpZGVvTXV0ZWQgJiYgdmlkZW9SZWYuY3VycmVudCAmJiB2aWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgICBjb25zdCB2aWRlb1RyYWNrcyA9IHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICB2aWRlb1RyYWNrcy5mb3JFYWNoKCh0cmFjazogeyBlbmFibGVkOiBib29sZWFuOyBzdG9wOiAoKSA9PiB2b2lkOyB9KSA9PiB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSBmYWxzZVxuICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICAgIH0sIDUwMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXJ0TG9jYWxWaWRlbyh2aWRlb1JlZikudGhlbiggKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50ICYmIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgICAgdXBkYXRlUmVtb3RlUGVlckNvbm5lY3Rpb25zKHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwMClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZCh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZDonLCBlcnIpO1xuICB9XG59Il0sIm5hbWVzIjpbInVwZGF0ZVJlbW90ZVBlZXJDb25uZWN0aW9ucyIsIlJlYWN0Iiwic2VydmVyVVJMIiwiY3JlYXRlUm9vbSIsInJvb21OYW1lIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJyb29tSWQiLCJyb29tX2lkIiwiY3JlYXRlZFJvb21OYW1lIiwicm9vbV9uYW1lIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0TGFuZ3VhZ2VzQXJyYXkiLCJuYW1lcyIsIm1hcCIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJkZWNvZGUiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm1ha2VWaWRlb0VsZW1lbnQiLCJlbGVtZW50SWQiLCJkaXNwbGF5TmFtZSIsIndyYXBwZXJEaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ2aWRXcmFwcGVyIiwidmlkIiwibmFtZVRleHQiLCJpZCIsImNsYXNzTmFtZSIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiYXV0b3BsYXkiLCJpbm5lclRleHQiLCJhcHBlbmRDaGlsZCIsImFkZFZpZGVvRWxlbWVudCIsInJlbW92ZVZpZGVvRWxlbWVudCIsInZpZGVvR3JpZCIsImdldEVsZW1lbnRCeUlkIiwibG9nIiwiZGl2IiwiZ2V0VmlkZW9PYmoiLCJzcmNPYmplY3QiLCJ0cmFja3MiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwicmVtb3ZlQXR0cmlidXRlIiwicmVtb3ZlIiwidmlkZW9PYmoiLCJkcmFnQW5kRHJvcCIsImVsZW1lbnQiLCJlbGVtZW50Q29udGFpbmVyIiwiY3VycmVudCIsImlzRHJhZ2dpbmciLCJkcmFnU3RhcnRYIiwiZHJhZ1N0YXJ0WSIsImRyYWdTdGFydExlZnQiLCJkcmFnU3RhcnRUb3AiLCJoYW5kbGVEcmFnU3RhcnQiLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImhhbmRsZURyYWdNb3ZlIiwiZGVsdGFYIiwiZGVsdGFZIiwibGVmdCIsInRvcCIsImhhbmRsZURyYWdFbmQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldEF1ZGlvTXV0ZVN0YXRlIiwic3RyZWFtIiwibXV0ZWQiLCJnZXRBdWRpb1RyYWNrcyIsImVuYWJsZWQiLCJzdG9wVmlkZW9Pbmx5IiwiZ2V0VmlkZW9UcmFja3MiLCJzZXRUaW1lb3V0Iiwic2V0VmlkZW9NdXRlU3RhdGUiLCJ2aWRlb1JlZiIsImxvY2FsU3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwidmlkZW8iLCJ0aGVuIiwiY2F0Y2giLCJ1dWlkdjQiLCJyZXBsYWNlIiwiYyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJ0b1N0cmluZyIsImdlbmVyYXRlQW5kU2F2ZVBlcm1hbmVudElkIiwicGVybWFuZW50SWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwibmV3UGVybWFuZW50SWQiLCJzZXRJdGVtIiwic3RhcnRMb2NhbFZpZGVvIiwiYXVkaW8iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9ubG9hZGVkbWV0YWRhdGEiLCJoYW5kbGVWaWRlb011dGUiLCJ2aWRlb011dGVkIiwiTWVkaWFTdHJlYW0iLCJ2aWRlb1RyYWNrcyIsImNvcHlUb0NsaXBib2FyZCIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/utils.ts\n"));

/***/ })

});