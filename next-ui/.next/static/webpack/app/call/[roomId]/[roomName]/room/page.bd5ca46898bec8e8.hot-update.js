"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/call/[roomId]/[roomName]/room/page",{

/***/ "(app-pages-browser)/./app/utils/socketNetworkHandlers.ts":
/*!********************************************!*\
  !*** ./app/utils/socketNetworkHandlers.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPeerConnection: function() { return /* binding */ createPeerConnection; },\n/* harmony export */   handleNegotiationNeededEvent: function() { return /* binding */ handleNegotiationNeededEvent; },\n/* harmony export */   invite: function() { return /* binding */ invite; },\n/* harmony export */   onConnect: function() { return /* binding */ onConnect; },\n/* harmony export */   onData: function() { return /* binding */ onData; },\n/* harmony export */   onUserConnect: function() { return /* binding */ onUserConnect; },\n/* harmony export */   onUserDisconnected: function() { return /* binding */ onUserDisconnected; },\n/* harmony export */   onUserList: function() { return /* binding */ onUserList; },\n/* harmony export */   sendViaServer: function() { return /* binding */ sendViaServer; },\n/* harmony export */   start_webrtc: function() { return /* binding */ start_webrtc; },\n/* harmony export */   updateRemotePeerConnections: function() { return /* binding */ updateRemotePeerConnections; }\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/utils */ \"(app-pages-browser)/./app/utils/utils.ts\");\n\nlet myID;\nlet _peer_list = {};\nconst onConnect = (socket, roomId, roomName, displayName, language)=>{\n    console.log(\"socket connected....\");\n    socket.emit(\"join-room\", {\n        room_id: roomId,\n        room_name: roomName,\n        display_name: displayName,\n        language: language\n    });\n};\nconst onUserConnect = (data)=>{\n    console.log(\"user-connect \", data);\n    let peer_id = data[\"sid\"];\n    let display_name = data[\"name\"];\n    _peer_list[peer_id] = undefined;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n};\nconst onUserDisconnected = (data)=>{\n    console.log(\"user-disconnect \", data);\n    let peer_id = data[\"sid\"];\n    closeConnection(peer_id);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n};\nconst onUserList = (data, socket, myVideo)=>{\n    console.log(\"user list recvd \", data);\n    myID = data[\"my_id\"];\n    if (\"list\" in data) {\n        let recvd_list = data[\"list\"];\n        try {\n            for(const peer_id in _peer_list){\n                if (!recvd_list.hasOwnProperty(peer_id)) {\n                    closeConnection(peer_id);\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n                }\n            }\n        } catch (ex) {\n            console.log(ex);\n        }\n        // add existing users to user list\n        for(let peer_id in recvd_list){\n            let display_name = recvd_list[peer_id];\n            _peer_list[peer_id] = undefined;\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n        }\n        start_webrtc(myVideo, socket);\n    }\n};\nconst closeConnection = (peer_id)=>{\n    if (peer_id in _peer_list) {\n        _peer_list[peer_id].onicecandidate = null;\n        _peer_list[peer_id].ontrack = null;\n        _peer_list[peer_id].onnegotiationneeded = null;\n        delete _peer_list[peer_id]; // remove user from user list\n    }\n};\nconst log_user_list = ()=>{\n    for(let key in _peer_list){\n        console.log(\"\".concat(key, \": \").concat(_peer_list[key]));\n    }\n};\n//---------------[ webrtc ]--------------------\nlet PC_CONFIG = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:stun1.l.google.com:19302\"\n            ]\n        }\n    ]\n};\nconst log_error = (e)=>{\n    console.log(\"[ERROR] \", e);\n};\nconst sendViaServer = (data, socket)=>{\n    socket.emit(\"data\", data);\n};\nconst onData = (msg, socket, myVideo)=>{\n    switch(msg[\"type\"]){\n        case \"offer\":\n            handleOfferMsg(msg, socket, myVideo);\n            break;\n        case \"answer\":\n            handleAnswerMsg(msg);\n            break;\n        case \"new-ice-candidate\":\n            handleNewICECandidateMsg(msg);\n            break;\n    }\n};\nconst start_webrtc = (myVideo, socket)=>{\n    // send offer to all other members\n    for(let peer_id in _peer_list){\n        invite(peer_id, myVideo, socket);\n    }\n};\nconst invite = (peer_id, myVideo, socket)=>{\n    if (_peer_list[peer_id]) {\n        console.log(\"[Not supposed to happen!] Attempting to start a connection that already exists!\");\n        return;\n    } else if (peer_id === myID) {\n        console.log(\"[Not supposed to happen!] Trying to connect to self!\");\n        return;\n    } else {\n        console.log(\"Creating peer connection for <\".concat(peer_id, \"> ...\"));\n        createPeerConnection(peer_id, socket);\n        let local_stream = myVideo === null || myVideo === void 0 ? void 0 : myVideo.srcObject;\n        if (local_stream && local_stream instanceof MediaStream) {\n            local_stream.getTracks().forEach((track)=>{\n                _peer_list[peer_id].addTrack(track, local_stream);\n            });\n        } else {\n            console.error(\"Local stream is null or not a MediaStream\");\n            console.log(myVideo);\n        }\n    }\n};\nconst createPeerConnection = (peer_id, socket)=>{\n    _peer_list[peer_id] = new RTCPeerConnection(PC_CONFIG);\n    _peer_list[peer_id].onicecandidate = (event)=>{\n        handleICECandidateEvent(event, peer_id, socket);\n    };\n    _peer_list[peer_id].ontrack = (event)=>{\n        handleTrackEvent(event, peer_id);\n    };\n    _peer_list[peer_id].onnegotiationneeded = ()=>{\n        handleNegotiationNeededEvent(peer_id, socket);\n    };\n};\nconst handleNegotiationNeededEvent = (peer_id, socket)=>{\n    _peer_list[peer_id].createOffer().then((offer)=>{\n        return _peer_list[peer_id].setLocalDescription(offer);\n    }).then(()=>{\n        console.log(\"sending offer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"offer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleOfferMsg = (msg, socket, myVideo)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"offer recieved from <\".concat(peer_id, \">\"));\n    createPeerConnection(peer_id, socket);\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc).then(()=>{\n        let local_stream = myVideo.srcObject;\n        local_stream.getTracks().forEach((track)=>{\n            try {\n                _peer_list[peer_id].addTrack(track, local_stream);\n            } catch (error) {\n                console.log(error);\n            }\n        });\n    }).then(()=>{\n        return _peer_list[peer_id].createAnswer();\n    }).then((answer)=>{\n        return _peer_list[peer_id].setLocalDescription(answer);\n    }).then(()=>{\n        console.log(\"sending answer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"answer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleAnswerMsg = (msg)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"answer recieved from <\".concat(peer_id, \">\"));\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc);\n};\nconst handleICECandidateEvent = (event, peer_id, socket)=>{\n    if (event.candidate) {\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"new-ice-candidate\",\n            \"candidate\": event.candidate\n        }, socket);\n    }\n};\nconst handleNewICECandidateMsg = (msg)=>{\n    let peer_id;\n    console.log(\"ICE candidate recieved from <\".concat(peer_id, \">\"));\n    let candidate = new RTCIceCandidate(msg.candidate);\n    _peer_list[msg[\"sender_id\"]].addIceCandidate(candidate).catch(log_error);\n};\nconst handleTrackEvent = (event, peer_id)=>{\n    console.log(\"track event recieved from <\".concat(peer_id, \">\"));\n    if (event.streams && peer_id) {\n        const videoObj = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.getVideoObj)(peer_id);\n        if (!videoObj) {\n            return;\n        }\n        videoObj.srcObject = event.streams[0];\n    }\n};\nfunction updateRemotePeerConnections(newStream) {\n    for(const peerId in _peer_list){\n        if (_peer_list.hasOwnProperty(peerId)) {\n            const peerConnection = _peer_list[peerId];\n            const senders = peerConnection.getSenders();\n            senders.forEach((sender)=>{\n                if (sender.track.kind === \"video\") {\n                    sender.replaceTrack(newStream.getVideoTracks()[0]);\n                }\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9zb2NrZXROZXR3b3JrSGFuZGxlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStFO0FBRS9FLElBQUlHO0FBQ0osSUFBSUMsYUFBa0IsQ0FBQztBQUVoQixNQUFNQyxZQUFZLENBQUNDLFFBQWFDLFFBQWFDLFVBQWVDLGFBQWtCQztJQUNqRkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1pOLE9BQU9PLElBQUksQ0FBQyxhQUFhO1FBQUNDLFNBQVNQO1FBQVFRLFdBQVdQO1FBQVVRLGNBQWNQO1FBQWFDLFVBQVVBO0lBQVE7QUFDakgsRUFBQztBQUVNLE1BQU1PLGdCQUFnQixDQUFDQztJQUMxQlAsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQk07SUFDN0IsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekIsSUFBSUYsZUFBZUUsSUFBSSxDQUFDLE9BQU87SUFDL0JkLFVBQVUsQ0FBQ2UsUUFBUSxHQUFHQztJQUN0QnBCLDZEQUFlQSxDQUFDbUIsU0FBU0g7QUFDN0IsRUFBQztBQUNNLE1BQU1LLHFCQUFxQixDQUFDSDtJQUMvQlAsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQk07SUFDaEMsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekJJLGdCQUFnQkg7SUFDaEJqQixnRUFBa0JBLENBQUNpQjtBQUN2QixFQUFDO0FBRU0sTUFBTUksYUFBYSxDQUFDTCxNQUFXWixRQUFha0I7SUFDL0NiLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JNO0lBQ2hDZixPQUFPZSxJQUFJLENBQUMsUUFBUTtJQUVwQixJQUFJLFVBQVVBLE1BQ2Q7UUFDSSxJQUFJTyxhQUFhUCxJQUFJLENBQUMsT0FBTztRQUM3QixJQUFJO1lBQ0EsSUFBSyxNQUFNQyxXQUFXZixXQUFZO2dCQUM5QixJQUFJLENBQUNxQixXQUFXQyxjQUFjLENBQUNQLFVBQVU7b0JBQ3JDRyxnQkFBZ0JIO29CQUNoQmpCLGdFQUFrQkEsQ0FBQ2lC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RyxDQUFDLDhCQUFzQyxPQUFSTyxTQUFRO0lBRWxELElBQUlxQyxNQUFNa0IsT0FBTyxJQUFJdkQsU0FBUztRQUMxQixNQUFNd0QsV0FBVzFFLHlEQUFXQSxDQUFDa0I7UUFDN0IsSUFBSSxDQUFDd0QsVUFBVTtZQUNYO1FBQ0o7UUFDQUEsU0FBUzNCLFNBQVMsR0FBR1EsTUFBTWtCLE9BQU8sQ0FBQyxFQUFFO0lBQ3pDO0FBQ0o7QUFFTyxTQUFTRSw0QkFBNEJDLFNBQTJDO0lBQ25GLElBQUssTUFBTUMsVUFBVTFFLFdBQVk7UUFDN0IsSUFBSUEsV0FBV3NCLGNBQWMsQ0FBQ29ELFNBQVM7WUFDbkMsTUFBTUMsaUJBQWlCM0UsVUFBVSxDQUFDMEUsT0FBTztZQUN6QyxNQUFNRSxVQUFVRCxlQUFlRSxVQUFVO1lBQ3pDRCxRQUFRN0IsT0FBTyxDQUFDLENBQUMrQjtnQkFDYixJQUFJQSxPQUFPOUIsS0FBSyxDQUFDK0IsSUFBSSxLQUFLLFNBQVM7b0JBQy9CRCxPQUFPRSxZQUFZLENBQUNQLFVBQVVRLGNBQWMsRUFBRSxDQUFDLEVBQUU7Z0JBQ3JEO1lBQ0o7UUFDSjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3V0aWxzL3NvY2tldE5ldHdvcmtIYW5kbGVycy50cz8xYzcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YWRkVmlkZW9FbGVtZW50LCBnZXRWaWRlb09iaiwgcmVtb3ZlVmlkZW9FbGVtZW50fSBmcm9tIFwiQC91dGlscy91dGlsc1wiO1xuXG5sZXQgbXlJRDogYW55O1xubGV0IF9wZWVyX2xpc3Q6IGFueSA9IHt9XG5cbmV4cG9ydCBjb25zdCBvbkNvbm5lY3QgPSAoc29ja2V0OiBhbnksIHJvb21JZDogYW55LCByb29tTmFtZTogYW55LCBkaXNwbGF5TmFtZTogYW55LCBsYW5ndWFnZTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJzb2NrZXQgY29ubmVjdGVkLi4uLlwiKTtcbiAgICBzb2NrZXQuZW1pdChcImpvaW4tcm9vbVwiLCB7cm9vbV9pZDogcm9vbUlkLCByb29tX25hbWU6IHJvb21OYW1lLCBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lLCBsYW5ndWFnZTogbGFuZ3VhZ2V9KTtcbn1cblxuZXhwb3J0IGNvbnN0IG9uVXNlckNvbm5lY3QgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJ1c2VyLWNvbm5lY3QgXCIsIGRhdGEpO1xuICAgIGxldCBwZWVyX2lkID0gZGF0YVtcInNpZFwiXTtcbiAgICBsZXQgZGlzcGxheV9uYW1lID0gZGF0YVtcIm5hbWVcIl07XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXSA9IHVuZGVmaW5lZDtcbiAgICBhZGRWaWRlb0VsZW1lbnQocGVlcl9pZCwgZGlzcGxheV9uYW1lKTtcbn1cbmV4cG9ydCBjb25zdCBvblVzZXJEaXNjb25uZWN0ZWQgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJ1c2VyLWRpc2Nvbm5lY3QgXCIsIGRhdGEpO1xuICAgIGxldCBwZWVyX2lkID0gZGF0YVtcInNpZFwiXTtcbiAgICBjbG9zZUNvbm5lY3Rpb24ocGVlcl9pZCk7XG4gICAgcmVtb3ZlVmlkZW9FbGVtZW50KHBlZXJfaWQpO1xufVxuXG5leHBvcnQgY29uc3Qgb25Vc2VyTGlzdCA9IChkYXRhOiBhbnksIHNvY2tldDogYW55LCBteVZpZGVvOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcInVzZXIgbGlzdCByZWN2ZCBcIiwgZGF0YSk7XG4gICAgbXlJRCA9IGRhdGFbXCJteV9pZFwiXTtcblxuICAgIGlmKCBcImxpc3RcIiBpbiBkYXRhKSAvLyBub3QgdGhlIGZpcnN0IHRvIGNvbm5lY3QgdG8gcm9vbSwgZXhpc3RpbmcgdXNlciBsaXN0IHJlY2lldmVkXG4gICAge1xuICAgICAgICBsZXQgcmVjdmRfbGlzdCA9IGRhdGFbXCJsaXN0XCJdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwZWVyX2lkIGluIF9wZWVyX2xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY3ZkX2xpc3QuaGFzT3duUHJvcGVydHkocGVlcl9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKHBlZXJfaWQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVWaWRlb0VsZW1lbnQocGVlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgZXhpc3RpbmcgdXNlcnMgdG8gdXNlciBsaXN0XG4gICAgICAgIGZvcihsZXQgcGVlcl9pZCBpbiByZWN2ZF9saXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZGlzcGxheV9uYW1lID0gcmVjdmRfbGlzdFtwZWVyX2lkXTtcbiAgICAgICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZGRWaWRlb0VsZW1lbnQocGVlcl9pZCwgZGlzcGxheV9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydF93ZWJydGMobXlWaWRlbywgc29ja2V0KTtcbiAgICB9XG59XG5cbmNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChwZWVyX2lkOiBzdHJpbmcpID0+IHtcbiAgICBpZihwZWVyX2lkIGluIF9wZWVyX2xpc3QpXG4gICAge1xuICAgICAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbnRyYWNrID0gbnVsbDtcbiAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcblxuICAgICAgICBkZWxldGUgX3BlZXJfbGlzdFtwZWVyX2lkXTsgLy8gcmVtb3ZlIHVzZXIgZnJvbSB1c2VyIGxpc3RcbiAgICB9XG59XG5cbmNvbnN0IGxvZ191c2VyX2xpc3QgPSAoKSA9PiB7XG4gICAgZm9yKGxldCBrZXkgaW4gX3BlZXJfbGlzdClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke2tleX06ICR7X3BlZXJfbGlzdFtrZXldfWApO1xuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS1bIHdlYnJ0YyBdLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IFBDX0NPTkZJRyA9IHtcbiAgICBpY2VTZXJ2ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicsXG4gICAgICAgICAgICAgICAgICAgICdzdHVuOnN0dW4xLmwuZ29vZ2xlLmNvbToxOTMwMicsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgIF1cbn07XG5cbmNvbnN0IGxvZ19lcnJvciA9IChlOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIltFUlJPUl0gXCIsIGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2VuZFZpYVNlcnZlciA9IChkYXRhOiBhbnksIHNvY2tldDogYW55KSA9PiB7XG4gICAgc29ja2V0LmVtaXQoXCJkYXRhXCIsIGRhdGEpO1xufVxuXG5leHBvcnQgY29uc3Qgb25EYXRhID0gKG1zZzogYW55LCBzb2NrZXQ6IGFueSwgbXlWaWRlbzogYW55KSA9PiB7XG4gICAgc3dpdGNoKG1zZ1tcInR5cGVcIl0pXG4gICAge1xuICAgICAgICBjYXNlIFwib2ZmZXJcIjpcbiAgICAgICAgICAgIGhhbmRsZU9mZmVyTXNnKG1zZywgc29ja2V0LCBteVZpZGVvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5zd2VyXCI6XG4gICAgICAgICAgICBoYW5kbGVBbnN3ZXJNc2cobXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV3LWljZS1jYW5kaWRhdGVcIjpcbiAgICAgICAgICAgIGhhbmRsZU5ld0lDRUNhbmRpZGF0ZU1zZyhtc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3RhcnRfd2VicnRjID0gKG15VmlkZW86IGFueSwgc29ja2V0OiBhbnkpID0+IHtcbiAgICAvLyBzZW5kIG9mZmVyIHRvIGFsbCBvdGhlciBtZW1iZXJzXG4gICAgZm9yKGxldCBwZWVyX2lkIGluIF9wZWVyX2xpc3QpXG4gICAge1xuICAgICAgICBpbnZpdGUocGVlcl9pZCwgbXlWaWRlbywgc29ja2V0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnZpdGUgPSAocGVlcl9pZDogc3RyaW5nLCBteVZpZGVvOiBhbnksIHNvY2tldDogYW55KSA9PiB7XG4gICAgaWYgKF9wZWVyX2xpc3RbcGVlcl9pZF0pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbTm90IHN1cHBvc2VkIHRvIGhhcHBlbiFdIEF0dGVtcHRpbmcgdG8gc3RhcnQgYSBjb25uZWN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMhXCIpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbHNlIGlmIChwZWVyX2lkID09PSBteUlEKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW05vdCBzdXBwb3NlZCB0byBoYXBwZW4hXSBUcnlpbmcgdG8gY29ubmVjdCB0byBzZWxmIVwiKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBwZWVyIGNvbm5lY3Rpb24gZm9yIDwke3BlZXJfaWR9PiAuLi5gKTtcbiAgICAgICAgY3JlYXRlUGVlckNvbm5lY3Rpb24ocGVlcl9pZCwgc29ja2V0KTtcblxuICAgICAgbGV0IGxvY2FsX3N0cmVhbSA9IG15VmlkZW8/LnNyY09iamVjdDtcbiAgICAgIGlmIChsb2NhbF9zdHJlYW0gJiYgbG9jYWxfc3RyZWFtIGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgbG9jYWxfc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBhbnkpPT57X3BlZXJfbGlzdFtwZWVyX2lkXS5hZGRUcmFjayh0cmFjaywgbG9jYWxfc3RyZWFtKTt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvY2FsIHN0cmVhbSBpcyBudWxsIG9yIG5vdCBhIE1lZGlhU3RyZWFtJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKG15VmlkZW8pXG4gICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAocGVlcl9pZDogc3RyaW5nLCBzb2NrZXQ6IGFueSkgPT4ge1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oUENfQ09ORklHKTtcblxuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub25pY2VjYW5kaWRhdGUgPSAoZXZlbnQ6IGFueSkgPT4ge2hhbmRsZUlDRUNhbmRpZGF0ZUV2ZW50KGV2ZW50LCBwZWVyX2lkLCBzb2NrZXQpfTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9udHJhY2sgPSAoZXZlbnQ6IGFueSkgPT4ge2hhbmRsZVRyYWNrRXZlbnQoZXZlbnQsIHBlZXJfaWQpfTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9ubmVnb3RpYXRpb25uZWVkZWQgPSAoKSA9PiB7aGFuZGxlTmVnb3RpYXRpb25OZWVkZWRFdmVudChwZWVyX2lkLCBzb2NrZXQpfTtcbn1cblxuXG5leHBvcnQgY29uc3QgaGFuZGxlTmVnb3RpYXRpb25OZWVkZWRFdmVudCA9IChwZWVyX2lkOiBzdHJpbmcsIHNvY2tldDogYW55KSA9PiB7XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5jcmVhdGVPZmZlcigpXG4gICAgLnRoZW4oKG9mZmVyOiBhbnkpPT57cmV0dXJuIF9wZWVyX2xpc3RbcGVlcl9pZF0uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7fSlcbiAgICAudGhlbigoKT0+e1xuICAgICAgICBjb25zb2xlLmxvZyhgc2VuZGluZyBvZmZlciB0byA8JHtwZWVyX2lkfT4gLi4uYCk7XG4gICAgICAgIHNlbmRWaWFTZXJ2ZXIoe1xuICAgICAgICAgICAgXCJzZW5kZXJfaWRcIjogbXlJRCxcbiAgICAgICAgICAgIFwidGFyZ2V0X2lkXCI6IHBlZXJfaWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJvZmZlclwiLFxuICAgICAgICAgICAgXCJzZHBcIjogX3BlZXJfbGlzdFtwZWVyX2lkXS5sb2NhbERlc2NyaXB0aW9uXG4gICAgICAgIH0sIHNvY2tldCk7XG4gICAgfSlcbiAgICAuY2F0Y2gobG9nX2Vycm9yKTtcbn1cblxuXG5jb25zdCBoYW5kbGVPZmZlck1zZyA9IChtc2c6IGFueSwgc29ja2V0OiBhbnksIG15VmlkZW86IGFueSkgPT4ge1xuICAgIGxldCBwZWVyX2lkID0gbXNnWydzZW5kZXJfaWQnXTtcblxuICAgIGNvbnNvbGUubG9nKGBvZmZlciByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuXG4gICAgY3JlYXRlUGVlckNvbm5lY3Rpb24ocGVlcl9pZCwgc29ja2V0KTtcbiAgICBsZXQgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24obXNnWydzZHAnXSk7XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgIC50aGVuKCgpPT57XG4gICAgICAgIGxldCBsb2NhbF9zdHJlYW0gPSBteVZpZGVvLnNyY09iamVjdDtcbiAgICAgICAgbG9jYWxfc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBhbnkpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0uYWRkVHJhY2sodHJhY2ssIGxvY2FsX3N0cmVhbSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oKCk9PntyZXR1cm4gX3BlZXJfbGlzdFtwZWVyX2lkXS5jcmVhdGVBbnN3ZXIoKTt9KVxuICAgIC50aGVuKChhbnN3ZXI6IGFueSk9PntyZXR1cm4gX3BlZXJfbGlzdFtwZWVyX2lkXS5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7fSlcbiAgICAudGhlbigoKT0+e1xuICAgICAgICBjb25zb2xlLmxvZyhgc2VuZGluZyBhbnN3ZXIgdG8gPCR7cGVlcl9pZH0+IC4uLmApO1xuICAgICAgICBzZW5kVmlhU2VydmVyKHtcbiAgICAgICAgICAgIFwic2VuZGVyX2lkXCI6IG15SUQsXG4gICAgICAgICAgICBcInRhcmdldF9pZFwiOiBwZWVyX2lkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYW5zd2VyXCIsXG4gICAgICAgICAgICBcInNkcFwiOiBfcGVlcl9saXN0W3BlZXJfaWRdLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgICAgfSwgc29ja2V0KTtcbiAgICB9KVxuICAgIC5jYXRjaChsb2dfZXJyb3IpO1xufVxuXG5jb25zdCBoYW5kbGVBbnN3ZXJNc2cgPSAobXNnOiBhbnkpID0+IHtcbiAgICBsZXQgcGVlcl9pZCA9IG1zZ1snc2VuZGVyX2lkJ107XG4gICAgY29uc29sZS5sb2coYGFuc3dlciByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuICAgIGxldCBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihtc2dbJ3NkcCddKTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpXG59XG5cblxuY29uc3QgaGFuZGxlSUNFQ2FuZGlkYXRlRXZlbnQgPSAoZXZlbnQ6IHsgY2FuZGlkYXRlOiBhbnk7IH0sIHBlZXJfaWQ6IHN0cmluZywgc29ja2V0OiBhbnkpID0+IHtcbiAgICBpZihldmVudC5jYW5kaWRhdGUpe1xuICAgICAgICBzZW5kVmlhU2VydmVyKHtcbiAgICAgICAgICAgIFwic2VuZGVyX2lkXCI6IG15SUQsXG4gICAgICAgICAgICBcInRhcmdldF9pZFwiOiBwZWVyX2lkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibmV3LWljZS1jYW5kaWRhdGVcIixcbiAgICAgICAgICAgIFwiY2FuZGlkYXRlXCI6IGV2ZW50LmNhbmRpZGF0ZVxuICAgICAgICB9LCBzb2NrZXQpO1xuICAgIH1cbn1cblxuY29uc3QgaGFuZGxlTmV3SUNFQ2FuZGlkYXRlTXNnID0gKG1zZzogYW55KSA9PiB7XG4gICAgbGV0IHBlZXJfaWQ7XG4gICAgY29uc29sZS5sb2coYElDRSBjYW5kaWRhdGUgcmVjaWV2ZWQgZnJvbSA8JHtwZWVyX2lkfT5gKTtcbiAgICBsZXQgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShtc2cuY2FuZGlkYXRlKTtcbiAgICBfcGVlcl9saXN0W21zZ1tcInNlbmRlcl9pZFwiXV0uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAuY2F0Y2gobG9nX2Vycm9yKTtcbn1cblxuXG5jb25zdCBoYW5kbGVUcmFja0V2ZW50ID0gKGV2ZW50OiBhbnksIHBlZXJfaWQ6IHN0cmluZykgPT5cbntcbiAgICBjb25zb2xlLmxvZyhgdHJhY2sgZXZlbnQgcmVjaWV2ZWQgZnJvbSA8JHtwZWVyX2lkfT5gKTtcblxuICAgIGlmIChldmVudC5zdHJlYW1zICYmIHBlZXJfaWQpIHtcbiAgICAgICAgY29uc3QgdmlkZW9PYmogPSBnZXRWaWRlb09iaihwZWVyX2lkKVxuICAgICAgICBpZiAoIXZpZGVvT2JqKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2aWRlb09iai5zcmNPYmplY3QgPSBldmVudC5zdHJlYW1zWzBdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlbW90ZVBlZXJDb25uZWN0aW9ucyhuZXdTdHJlYW06IHsgZ2V0VmlkZW9UcmFja3M6ICgpID0+IGFueVtdOyB9KSB7XG4gICAgZm9yIChjb25zdCBwZWVySWQgaW4gX3BlZXJfbGlzdCkge1xuICAgICAgICBpZiAoX3BlZXJfbGlzdC5oYXNPd25Qcm9wZXJ0eShwZWVySWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IF9wZWVyX2xpc3RbcGVlcklkXTtcbiAgICAgICAgICAgIGNvbnN0IHNlbmRlcnMgPSBwZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCk7XG4gICAgICAgICAgICBzZW5kZXJzLmZvckVhY2goKHNlbmRlcjogeyB0cmFjazogeyBraW5kOiBzdHJpbmc7IH07IHJlcGxhY2VUcmFjazogKGFyZzA6IGFueSkgPT4gdm9pZDsgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZW5kZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXIucmVwbGFjZVRyYWNrKG5ld1N0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0iXSwibmFtZXMiOlsiYWRkVmlkZW9FbGVtZW50IiwiZ2V0VmlkZW9PYmoiLCJyZW1vdmVWaWRlb0VsZW1lbnQiLCJteUlEIiwiX3BlZXJfbGlzdCIsIm9uQ29ubmVjdCIsInNvY2tldCIsInJvb21JZCIsInJvb21OYW1lIiwiZGlzcGxheU5hbWUiLCJsYW5ndWFnZSIsImNvbnNvbGUiLCJsb2ciLCJlbWl0Iiwicm9vbV9pZCIsInJvb21fbmFtZSIsImRpc3BsYXlfbmFtZSIsIm9uVXNlckNvbm5lY3QiLCJkYXRhIiwicGVlcl9pZCIsInVuZGVmaW5lZCIsIm9uVXNlckRpc2Nvbm5lY3RlZCIsImNsb3NlQ29ubmVjdGlvbiIsIm9uVXNlckxpc3QiLCJteVZpZGVvIiwicmVjdmRfbGlzdCIsImhhc093blByb3BlcnR5IiwiZXgiLCJzdGFydF93ZWJydGMiLCJvbmljZWNhbmRpZGF0ZSIsIm9udHJhY2siLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwibG9nX3VzZXJfbGlzdCIsImtleSIsIlBDX0NPTkZJRyIsImljZVNlcnZlcnMiLCJ1cmxzIiwibG9nX2Vycm9yIiwiZSIsInNlbmRWaWFTZXJ2ZXIiLCJvbkRhdGEiLCJtc2ciLCJoYW5kbGVPZmZlck1zZyIsImhhbmRsZUFuc3dlck1zZyIsImhhbmRsZU5ld0lDRUNhbmRpZGF0ZU1zZyIsImludml0ZSIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwibG9jYWxfc3RyZWFtIiwic3JjT2JqZWN0IiwiTWVkaWFTdHJlYW0iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJhZGRUcmFjayIsImVycm9yIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJldmVudCIsImhhbmRsZUlDRUNhbmRpZGF0ZUV2ZW50IiwiaGFuZGxlVHJhY2tFdmVudCIsImhhbmRsZU5lZ290aWF0aW9uTmVlZGVkRXZlbnQiLCJjcmVhdGVPZmZlciIsInRoZW4iLCJvZmZlciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiY2F0Y2giLCJkZXNjIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJjcmVhdGVBbnN3ZXIiLCJhbnN3ZXIiLCJjYW5kaWRhdGUiLCJSVENJY2VDYW5kaWRhdGUiLCJhZGRJY2VDYW5kaWRhdGUiLCJzdHJlYW1zIiwidmlkZW9PYmoiLCJ1cGRhdGVSZW1vdGVQZWVyQ29ubmVjdGlvbnMiLCJuZXdTdHJlYW0iLCJwZWVySWQiLCJwZWVyQ29ubmVjdGlvbiIsInNlbmRlcnMiLCJnZXRTZW5kZXJzIiwic2VuZGVyIiwia2luZCIsInJlcGxhY2VUcmFjayIsImdldFZpZGVvVHJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/socketNetworkHandlers.ts\n"));

/***/ })

});