"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/call/[roomId]/[roomName]/room/page",{

/***/ "(app-pages-browser)/./app/utils/socketNetworkHandlers.ts":
/*!********************************************!*\
  !*** ./app/utils/socketNetworkHandlers.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPeerConnection: function() { return /* binding */ createPeerConnection; },\n/* harmony export */   handleNegotiationNeededEvent: function() { return /* binding */ handleNegotiationNeededEvent; },\n/* harmony export */   invite: function() { return /* binding */ invite; },\n/* harmony export */   onConnect: function() { return /* binding */ onConnect; },\n/* harmony export */   onData: function() { return /* binding */ onData; },\n/* harmony export */   onUserConnect: function() { return /* binding */ onUserConnect; },\n/* harmony export */   onUserDisconnected: function() { return /* binding */ onUserDisconnected; },\n/* harmony export */   onUserList: function() { return /* binding */ onUserList; },\n/* harmony export */   sendViaServer: function() { return /* binding */ sendViaServer; },\n/* harmony export */   start_webrtc: function() { return /* binding */ start_webrtc; },\n/* harmony export */   updateRemotePeerConnections: function() { return /* binding */ updateRemotePeerConnections; }\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/utils */ \"(app-pages-browser)/./app/utils/utils.ts\");\n\nlet myID;\nlet _peer_list = {};\nconst onConnect = (socket, roomId, roomName, displayName, language)=>{\n    console.log(\"socket connected....\");\n    socket.emit(\"join-room\", {\n        room_id: roomId,\n        room_name: roomName,\n        display_name: displayName,\n        language: language\n    });\n};\nconst onUserConnect = (data)=>{\n    console.log(\"user-connect \", data);\n    let peer_id = data[\"sid\"];\n    let display_name = data[\"name\"];\n    _peer_list[peer_id] = undefined;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n};\nconst onUserDisconnected = (data)=>{\n    console.log(\"user-disconnect \", data);\n    let peer_id = data[\"sid\"];\n    closeConnection(peer_id);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n};\nconst onUserList = (data, socket, myVideo)=>{\n    console.log(\"user list recvd \", data);\n    myID = data[\"my_id\"];\n    if (\"list\" in data) {\n        let recvd_list = data[\"list\"];\n        try {\n            for(const peer_id in _peer_list){\n                if (!recvd_list.hasOwnProperty(peer_id)) {\n                    closeConnection(peer_id);\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n                }\n            }\n        } catch (ex) {\n            console.log(ex);\n        }\n        // add existing users to user list\n        for(let peer_id in recvd_list){\n            let display_name = recvd_list[peer_id];\n            _peer_list[peer_id] = undefined;\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n        }\n        start_webrtc(myVideo, socket);\n    }\n};\nconst closeConnection = (peer_id)=>{\n    if (peer_id in _peer_list) {\n        _peer_list[peer_id].onicecandidate = null;\n        _peer_list[peer_id].ontrack = null;\n        _peer_list[peer_id].onnegotiationneeded = null;\n        delete _peer_list[peer_id]; // remove user from user list\n    }\n};\nconst log_user_list = ()=>{\n    for(let key in _peer_list){\n        console.log(\"\".concat(key, \": \").concat(_peer_list[key]));\n    }\n};\n//---------------[ webrtc ]--------------------\nlet PC_CONFIG = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:stun1.l.google.com:19302\"\n            ]\n        }\n    ]\n};\nconst log_error = (e)=>{\n    console.log(\"[ERROR] \", e);\n};\nconst sendViaServer = (data, socket)=>{\n    socket.emit(\"data\", data);\n};\nconst onData = (msg, socket, myVideo)=>{\n    switch(msg[\"type\"]){\n        case \"offer\":\n            handleOfferMsg(msg, socket, myVideo);\n            break;\n        case \"answer\":\n            handleAnswerMsg(msg);\n            break;\n        case \"new-ice-candidate\":\n            handleNewICECandidateMsg(msg);\n            break;\n    }\n};\nconst start_webrtc = (myVideo, socket)=>{\n    // send offer to all other members\n    for(let peer_id in _peer_list){\n        invite(peer_id, myVideo, socket);\n    }\n};\nconst invite = (peer_id, myVideo, socket)=>{\n    if (_peer_list[peer_id]) {\n        console.log(\"[Not supposed to happen!] Attempting to start a connection that already exists!\");\n        return;\n    } else if (peer_id === myID) {\n        console.log(\"[Not supposed to happen!] Trying to connect to self!\");\n        return;\n    } else {\n        console.log(\"Creating peer connection for <\".concat(peer_id, \"> ...\"));\n        createPeerConnection(peer_id, socket);\n        let local_stream = myVideo === null || myVideo === void 0 ? void 0 : myVideo.srcObject;\n        //   let local_stream: MediaProvider | HTMLVideoElement | null = document.getElementById('local_stream') as HTMLVideoElement\n        //   if (local_stream) {\n        //       local_stream = local_stream.srcObject\n        //   }\n        if (local_stream && local_stream instanceof MediaStream) {\n            local_stream.getTracks().forEach((track)=>{\n                _peer_list[peer_id].addTrack(track, local_stream);\n            });\n        } else {\n            console.error(\"Local stream is null or not a MediaStream\");\n            console.log(local_stream);\n        }\n    }\n};\nconst createPeerConnection = (peer_id, socket)=>{\n    _peer_list[peer_id] = new RTCPeerConnection(PC_CONFIG);\n    _peer_list[peer_id].onicecandidate = (event)=>{\n        handleICECandidateEvent(event, peer_id, socket);\n    };\n    _peer_list[peer_id].ontrack = (event)=>{\n        handleTrackEvent(event, peer_id);\n    };\n    _peer_list[peer_id].onnegotiationneeded = ()=>{\n        handleNegotiationNeededEvent(peer_id, socket);\n    };\n};\nconst handleNegotiationNeededEvent = (peer_id, socket)=>{\n    _peer_list[peer_id].createOffer().then((offer)=>{\n        return _peer_list[peer_id].setLocalDescription(offer);\n    }).then(()=>{\n        console.log(\"sending offer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"offer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleOfferMsg = (msg, socket, myVideo)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"offer recieved from <\".concat(peer_id, \">\"));\n    createPeerConnection(peer_id, socket);\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc).then(()=>{\n        let local_stream = myVideo.srcObject;\n        local_stream.getTracks().forEach((track)=>{\n            try {\n                _peer_list[peer_id].addTrack(track, local_stream);\n            } catch (error) {\n                console.log(error);\n            }\n        });\n    }).then(()=>{\n        return _peer_list[peer_id].createAnswer();\n    }).then((answer)=>{\n        return _peer_list[peer_id].setLocalDescription(answer);\n    }).then(()=>{\n        console.log(\"sending answer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"answer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleAnswerMsg = (msg)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"answer recieved from <\".concat(peer_id, \">\"));\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc);\n};\nconst handleICECandidateEvent = (event, peer_id, socket)=>{\n    if (event.candidate) {\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"new-ice-candidate\",\n            \"candidate\": event.candidate\n        }, socket);\n    }\n};\nconst handleNewICECandidateMsg = (msg)=>{\n    let peer_id;\n    console.log(\"ICE candidate recieved from <\".concat(peer_id, \">\"));\n    let candidate = new RTCIceCandidate(msg.candidate);\n    _peer_list[msg[\"sender_id\"]].addIceCandidate(candidate).catch(log_error);\n};\nconst handleTrackEvent = (event, peer_id)=>{\n    console.log(\"track event recieved from <\".concat(peer_id, \">\"));\n    if (event.streams && peer_id) {\n        const videoObj = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.getVideoObj)(peer_id);\n        if (!videoObj) {\n            return;\n        }\n        videoObj.srcObject = event.streams[0];\n    }\n};\nfunction updateRemotePeerConnections(newStream) {\n    for(const peerId in _peer_list){\n        if (_peer_list.hasOwnProperty(peerId)) {\n            const peerConnection = _peer_list[peerId];\n            const senders = peerConnection.getSenders();\n            senders.forEach((sender)=>{\n                if (sender.track.kind === \"video\") {\n                    sender.replaceTrack(newStream.getVideoTracks()[0]);\n                }\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9zb2NrZXROZXR3b3JrSGFuZGxlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStFO0FBRS9FLElBQUlHO0FBQ0osSUFBSUMsYUFBa0IsQ0FBQztBQUVoQixNQUFNQyxZQUFZLENBQUNDLFFBQWFDLFFBQWFDLFVBQWVDLGFBQWtCQztJQUNqRkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1pOLE9BQU9PLElBQUksQ0FBQyxhQUFhO1FBQUNDLFNBQVNQO1FBQVFRLFdBQVdQO1FBQVVRLGNBQWNQO1FBQWFDLFVBQVVBO0lBQVE7QUFDakgsRUFBQztBQUVNLE1BQU1PLGdCQUFnQixDQUFDQztJQUMxQlAsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQk07SUFDN0IsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekIsSUFBSUYsZUFBZUUsSUFBSSxDQUFDLE9BQU87SUFDL0JkLFVBQVUsQ0FBQ2UsUUFBUSxHQUFHQztJQUN0QnBCLDZEQUFlQSxDQUFDbUIsU0FBU0g7QUFDN0IsRUFBQztBQUNNLE1BQU1LLHFCQUFxQixDQUFDSDtJQUMvQlAsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQk07SUFDaEMsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekJJLGdCQUFnQkg7SUFDaEJqQixnRUFBa0JBLENBQUNpQjtBQUN2QixFQUFDO0FBRU0sTUFBTUksYUFBYSxDQUFDTCxNQUFXWixRQUFha0I7SUFDL0NiLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JNO0lBQ2hDZixPQUFPZSxJQUFJLENBQUMsUUFBUTtJQUVwQixJQUFJLFVBQVVBLE1BQ2Q7UUFDSSxJQUFJTyxhQUFhUCxJQUFJLENBQUMsT0FBTztRQUM3QixJQUFJO1lBQ0EsSUFBSyxNQUFNQyxXQUFXZixXQUFZO2dCQUM5QixJQUFJLENBQUNxQixXQUFXQyxjQUFjLENBQUNQLFVBQVU7b0JBQ3JDRyxnQkFBZ0JIO29CQUNoQmpCLGdFQUFrQkEsQ0FBQ2lC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O0FBR0EsTUFBTXFCLG1CQUFtQixDQUFDRixPQUFZckM7SUFFbENSLFFBQVFDLEdBQUcsQ0FBQyw4QkFBc0MsT0FBUk8sU0FBUTtJQUVsRCxJQUFJcUMsTUFBTWtCLE9BQU8sSUFBSXZELFNBQVM7UUFDMUIsTUFBTXdELFdBQVcxRSx5REFBV0EsQ0FBQ2tCO1FBQzdCLElBQUksQ0FBQ3dELFVBQVU7WUFDWDtRQUNKO1FBQ0FBLFNBQVMzQixTQUFTLEdBQUdRLE1BQU1rQixPQUFPLENBQUMsRUFBRTtJQUN6QztBQUNKO0FBRU8sU0FBU0UsNEJBQTRCQyxTQUEyQztJQUNuRixJQUFLLE1BQU1DLFVBQVUxRSxXQUFZO1FBQzdCLElBQUlBLFdBQVdzQixjQUFjLENBQUNvRCxTQUFTO1lBQ25DLE1BQU1DLGlCQUFpQjNFLFVBQVUsQ0FBQzBFLE9BQU87WUFDekMsTUFBTUUsVUFBVUQsZUFBZUUsVUFBVTtZQUN6Q0QsUUFBUTdCLE9BQU8sQ0FBQyxDQUFDK0I7Z0JBQ2IsSUFBSUEsT0FBTzlCLEtBQUssQ0FBQytCLElBQUksS0FBSyxTQUFTO29CQUMvQkQsT0FBT0UsWUFBWSxDQUFDUCxVQUFVUSxjQUFjLEVBQUUsQ0FBQyxFQUFFO2dCQUNyRDtZQUNKO1FBQ0o7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC91dGlscy9zb2NrZXROZXR3b3JrSGFuZGxlcnMudHM/MWM3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FkZFZpZGVvRWxlbWVudCwgZ2V0VmlkZW9PYmosIHJlbW92ZVZpZGVvRWxlbWVudH0gZnJvbSBcIkAvdXRpbHMvdXRpbHNcIjtcblxubGV0IG15SUQ6IGFueTtcbmxldCBfcGVlcl9saXN0OiBhbnkgPSB7fVxuXG5leHBvcnQgY29uc3Qgb25Db25uZWN0ID0gKHNvY2tldDogYW55LCByb29tSWQ6IGFueSwgcm9vbU5hbWU6IGFueSwgZGlzcGxheU5hbWU6IGFueSwgbGFuZ3VhZ2U6IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwic29ja2V0IGNvbm5lY3RlZC4uLi5cIik7XG4gICAgc29ja2V0LmVtaXQoXCJqb2luLXJvb21cIiwge3Jvb21faWQ6IHJvb21JZCwgcm9vbV9uYW1lOiByb29tTmFtZSwgZGlzcGxheV9uYW1lOiBkaXNwbGF5TmFtZSwgbGFuZ3VhZ2U6IGxhbmd1YWdlfSk7XG59XG5cbmV4cG9ydCBjb25zdCBvblVzZXJDb25uZWN0ID0gKGRhdGE6IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwidXNlci1jb25uZWN0IFwiLCBkYXRhKTtcbiAgICBsZXQgcGVlcl9pZCA9IGRhdGFbXCJzaWRcIl07XG4gICAgbGV0IGRpc3BsYXlfbmFtZSA9IGRhdGFbXCJuYW1lXCJdO1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0gPSB1bmRlZmluZWQ7XG4gICAgYWRkVmlkZW9FbGVtZW50KHBlZXJfaWQsIGRpc3BsYXlfbmFtZSk7XG59XG5leHBvcnQgY29uc3Qgb25Vc2VyRGlzY29ubmVjdGVkID0gKGRhdGE6IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwidXNlci1kaXNjb25uZWN0IFwiLCBkYXRhKTtcbiAgICBsZXQgcGVlcl9pZCA9IGRhdGFbXCJzaWRcIl07XG4gICAgY2xvc2VDb25uZWN0aW9uKHBlZXJfaWQpO1xuICAgIHJlbW92ZVZpZGVvRWxlbWVudChwZWVyX2lkKTtcbn1cblxuZXhwb3J0IGNvbnN0IG9uVXNlckxpc3QgPSAoZGF0YTogYW55LCBzb2NrZXQ6IGFueSwgbXlWaWRlbzogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJ1c2VyIGxpc3QgcmVjdmQgXCIsIGRhdGEpO1xuICAgIG15SUQgPSBkYXRhW1wibXlfaWRcIl07XG5cbiAgICBpZiggXCJsaXN0XCIgaW4gZGF0YSkgLy8gbm90IHRoZSBmaXJzdCB0byBjb25uZWN0IHRvIHJvb20sIGV4aXN0aW5nIHVzZXIgbGlzdCByZWNpZXZlZFxuICAgIHtcbiAgICAgICAgbGV0IHJlY3ZkX2xpc3QgPSBkYXRhW1wibGlzdFwiXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGVlcl9pZCBpbiBfcGVlcl9saXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWN2ZF9saXN0Lmhhc093blByb3BlcnR5KHBlZXJfaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihwZWVyX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVmlkZW9FbGVtZW50KHBlZXJfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGV4aXN0aW5nIHVzZXJzIHRvIHVzZXIgbGlzdFxuICAgICAgICBmb3IobGV0IHBlZXJfaWQgaW4gcmVjdmRfbGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlfbmFtZSA9IHJlY3ZkX2xpc3RbcGVlcl9pZF07XG4gICAgICAgICAgICBfcGVlcl9saXN0W3BlZXJfaWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWRkVmlkZW9FbGVtZW50KHBlZXJfaWQsIGRpc3BsYXlfbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRfd2VicnRjKG15VmlkZW8sIHNvY2tldCk7XG4gICAgfVxufVxuXG5jb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAocGVlcl9pZDogc3RyaW5nKSA9PiB7XG4gICAgaWYocGVlcl9pZCBpbiBfcGVlcl9saXN0KVxuICAgIHtcbiAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub250cmFjayA9IG51bGw7XG4gICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG5cbiAgICAgICAgZGVsZXRlIF9wZWVyX2xpc3RbcGVlcl9pZF07IC8vIHJlbW92ZSB1c2VyIGZyb20gdXNlciBsaXN0XG4gICAgfVxufVxuXG5jb25zdCBsb2dfdXNlcl9saXN0ID0gKCkgPT4ge1xuICAgIGZvcihsZXQga2V5IGluIF9wZWVyX2xpc3QpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtrZXl9OiAke19wZWVyX2xpc3Rba2V5XX1gKTtcbiAgICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tWyB3ZWJydGMgXS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBQQ19DT05GSUcgPSB7XG4gICAgaWNlU2VydmVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICB1cmxzOiBbJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAgICAgICAgICAgICAnc3R1bjpzdHVuMS5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAgICAgICAgICAgICAvLyAnc3R1bjpzdHVuMi5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAgICAgICAgICAgICAvLyAnc3R1bjpzdHVuMy5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAgICAgICAgICAgICAvLyAnc3R1bjpzdHVuNC5sLmdvb2dsZS5jb206MTkzMDInXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgIF1cbn07XG5cbmNvbnN0IGxvZ19lcnJvciA9IChlOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIltFUlJPUl0gXCIsIGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2VuZFZpYVNlcnZlciA9IChkYXRhOiBhbnksIHNvY2tldDogYW55KSA9PiB7XG4gICAgc29ja2V0LmVtaXQoXCJkYXRhXCIsIGRhdGEpO1xufVxuXG5leHBvcnQgY29uc3Qgb25EYXRhID0gKG1zZzogYW55LCBzb2NrZXQ6IGFueSwgbXlWaWRlbzogYW55KSA9PiB7XG4gICAgc3dpdGNoKG1zZ1tcInR5cGVcIl0pXG4gICAge1xuICAgICAgICBjYXNlIFwib2ZmZXJcIjpcbiAgICAgICAgICAgIGhhbmRsZU9mZmVyTXNnKG1zZywgc29ja2V0LCBteVZpZGVvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5zd2VyXCI6XG4gICAgICAgICAgICBoYW5kbGVBbnN3ZXJNc2cobXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV3LWljZS1jYW5kaWRhdGVcIjpcbiAgICAgICAgICAgIGhhbmRsZU5ld0lDRUNhbmRpZGF0ZU1zZyhtc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3RhcnRfd2VicnRjID0gKG15VmlkZW86IGFueSwgc29ja2V0OiBhbnkpID0+IHtcbiAgICAvLyBzZW5kIG9mZmVyIHRvIGFsbCBvdGhlciBtZW1iZXJzXG4gICAgZm9yKGxldCBwZWVyX2lkIGluIF9wZWVyX2xpc3QpXG4gICAge1xuICAgICAgICBpbnZpdGUocGVlcl9pZCwgbXlWaWRlbywgc29ja2V0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnZpdGUgPSAocGVlcl9pZDogc3RyaW5nLCBteVZpZGVvOiBhbnksIHNvY2tldDogYW55KSA9PiB7XG4gICAgaWYgKF9wZWVyX2xpc3RbcGVlcl9pZF0pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbTm90IHN1cHBvc2VkIHRvIGhhcHBlbiFdIEF0dGVtcHRpbmcgdG8gc3RhcnQgYSBjb25uZWN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMhXCIpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbHNlIGlmIChwZWVyX2lkID09PSBteUlEKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW05vdCBzdXBwb3NlZCB0byBoYXBwZW4hXSBUcnlpbmcgdG8gY29ubmVjdCB0byBzZWxmIVwiKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBwZWVyIGNvbm5lY3Rpb24gZm9yIDwke3BlZXJfaWR9PiAuLi5gKTtcbiAgICAgICAgY3JlYXRlUGVlckNvbm5lY3Rpb24ocGVlcl9pZCwgc29ja2V0KTtcblxuICAgICAgbGV0IGxvY2FsX3N0cmVhbSA9IG15VmlkZW8/LnNyY09iamVjdDtcbiAgICAgIC8vICAgbGV0IGxvY2FsX3N0cmVhbTogTWVkaWFQcm92aWRlciB8IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvY2FsX3N0cmVhbScpIGFzIEhUTUxWaWRlb0VsZW1lbnRcbiAgICAgIC8vICAgaWYgKGxvY2FsX3N0cmVhbSkge1xuICAgICAgLy8gICAgICAgbG9jYWxfc3RyZWFtID0gbG9jYWxfc3RyZWFtLnNyY09iamVjdFxuICAgICAgLy8gICB9XG4gICAgICBpZiAobG9jYWxfc3RyZWFtICYmIGxvY2FsX3N0cmVhbSBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgICAgIGxvY2FsX3N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogYW55KT0+e19wZWVyX2xpc3RbcGVlcl9pZF0uYWRkVHJhY2sodHJhY2ssIGxvY2FsX3N0cmVhbSk7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdMb2NhbCBzdHJlYW0gaXMgbnVsbCBvciBub3QgYSBNZWRpYVN0cmVhbScpO1xuICAgICAgICBjb25zb2xlLmxvZyhsb2NhbF9zdHJlYW0pXG4gICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAocGVlcl9pZDogc3RyaW5nLCBzb2NrZXQ6IGFueSkgPT4ge1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oUENfQ09ORklHKTtcblxuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub25pY2VjYW5kaWRhdGUgPSAoZXZlbnQ6IGFueSkgPT4ge2hhbmRsZUlDRUNhbmRpZGF0ZUV2ZW50KGV2ZW50LCBwZWVyX2lkLCBzb2NrZXQpfTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9udHJhY2sgPSAoZXZlbnQ6IGFueSkgPT4ge2hhbmRsZVRyYWNrRXZlbnQoZXZlbnQsIHBlZXJfaWQpfTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9ubmVnb3RpYXRpb25uZWVkZWQgPSAoKSA9PiB7aGFuZGxlTmVnb3RpYXRpb25OZWVkZWRFdmVudChwZWVyX2lkLCBzb2NrZXQpfTtcbn1cblxuXG5leHBvcnQgY29uc3QgaGFuZGxlTmVnb3RpYXRpb25OZWVkZWRFdmVudCA9IChwZWVyX2lkOiBzdHJpbmcsIHNvY2tldDogYW55KSA9PiB7XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5jcmVhdGVPZmZlcigpXG4gICAgLnRoZW4oKG9mZmVyOiBhbnkpPT57cmV0dXJuIF9wZWVyX2xpc3RbcGVlcl9pZF0uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7fSlcbiAgICAudGhlbigoKT0+e1xuICAgICAgICBjb25zb2xlLmxvZyhgc2VuZGluZyBvZmZlciB0byA8JHtwZWVyX2lkfT4gLi4uYCk7XG4gICAgICAgIHNlbmRWaWFTZXJ2ZXIoe1xuICAgICAgICAgICAgXCJzZW5kZXJfaWRcIjogbXlJRCxcbiAgICAgICAgICAgIFwidGFyZ2V0X2lkXCI6IHBlZXJfaWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJvZmZlclwiLFxuICAgICAgICAgICAgXCJzZHBcIjogX3BlZXJfbGlzdFtwZWVyX2lkXS5sb2NhbERlc2NyaXB0aW9uXG4gICAgICAgIH0sIHNvY2tldCk7XG4gICAgfSlcbiAgICAuY2F0Y2gobG9nX2Vycm9yKTtcbn1cblxuXG5jb25zdCBoYW5kbGVPZmZlck1zZyA9IChtc2c6IGFueSwgc29ja2V0OiBhbnksIG15VmlkZW86IGFueSkgPT4ge1xuICAgIGxldCBwZWVyX2lkID0gbXNnWydzZW5kZXJfaWQnXTtcblxuICAgIGNvbnNvbGUubG9nKGBvZmZlciByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuXG4gICAgY3JlYXRlUGVlckNvbm5lY3Rpb24ocGVlcl9pZCwgc29ja2V0KTtcbiAgICBsZXQgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24obXNnWydzZHAnXSk7XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgIC50aGVuKCgpPT57XG4gICAgICAgIGxldCBsb2NhbF9zdHJlYW0gPSBteVZpZGVvLnNyY09iamVjdDtcbiAgICAgICAgbG9jYWxfc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBhbnkpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0uYWRkVHJhY2sodHJhY2ssIGxvY2FsX3N0cmVhbSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oKCk9PntyZXR1cm4gX3BlZXJfbGlzdFtwZWVyX2lkXS5jcmVhdGVBbnN3ZXIoKTt9KVxuICAgIC50aGVuKChhbnN3ZXI6IGFueSk9PntyZXR1cm4gX3BlZXJfbGlzdFtwZWVyX2lkXS5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7fSlcbiAgICAudGhlbigoKT0+e1xuICAgICAgICBjb25zb2xlLmxvZyhgc2VuZGluZyBhbnN3ZXIgdG8gPCR7cGVlcl9pZH0+IC4uLmApO1xuICAgICAgICBzZW5kVmlhU2VydmVyKHtcbiAgICAgICAgICAgIFwic2VuZGVyX2lkXCI6IG15SUQsXG4gICAgICAgICAgICBcInRhcmdldF9pZFwiOiBwZWVyX2lkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYW5zd2VyXCIsXG4gICAgICAgICAgICBcInNkcFwiOiBfcGVlcl9saXN0W3BlZXJfaWRdLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgICAgfSwgc29ja2V0KTtcbiAgICB9KVxuICAgIC5jYXRjaChsb2dfZXJyb3IpO1xufVxuXG5jb25zdCBoYW5kbGVBbnN3ZXJNc2cgPSAobXNnOiBhbnkpID0+IHtcbiAgICBsZXQgcGVlcl9pZCA9IG1zZ1snc2VuZGVyX2lkJ107XG4gICAgY29uc29sZS5sb2coYGFuc3dlciByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuICAgIGxldCBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihtc2dbJ3NkcCddKTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpXG59XG5cblxuY29uc3QgaGFuZGxlSUNFQ2FuZGlkYXRlRXZlbnQgPSAoZXZlbnQ6IHsgY2FuZGlkYXRlOiBhbnk7IH0sIHBlZXJfaWQ6IHN0cmluZywgc29ja2V0OiBhbnkpID0+IHtcbiAgICBpZihldmVudC5jYW5kaWRhdGUpe1xuICAgICAgICBzZW5kVmlhU2VydmVyKHtcbiAgICAgICAgICAgIFwic2VuZGVyX2lkXCI6IG15SUQsXG4gICAgICAgICAgICBcInRhcmdldF9pZFwiOiBwZWVyX2lkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibmV3LWljZS1jYW5kaWRhdGVcIixcbiAgICAgICAgICAgIFwiY2FuZGlkYXRlXCI6IGV2ZW50LmNhbmRpZGF0ZVxuICAgICAgICB9LCBzb2NrZXQpO1xuICAgIH1cbn1cblxuY29uc3QgaGFuZGxlTmV3SUNFQ2FuZGlkYXRlTXNnID0gKG1zZzogYW55KSA9PiB7XG4gICAgbGV0IHBlZXJfaWQ7XG4gICAgY29uc29sZS5sb2coYElDRSBjYW5kaWRhdGUgcmVjaWV2ZWQgZnJvbSA8JHtwZWVyX2lkfT5gKTtcbiAgICBsZXQgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShtc2cuY2FuZGlkYXRlKTtcbiAgICBfcGVlcl9saXN0W21zZ1tcInNlbmRlcl9pZFwiXV0uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAuY2F0Y2gobG9nX2Vycm9yKTtcbn1cblxuXG5jb25zdCBoYW5kbGVUcmFja0V2ZW50ID0gKGV2ZW50OiBhbnksIHBlZXJfaWQ6IHN0cmluZykgPT5cbntcbiAgICBjb25zb2xlLmxvZyhgdHJhY2sgZXZlbnQgcmVjaWV2ZWQgZnJvbSA8JHtwZWVyX2lkfT5gKTtcblxuICAgIGlmIChldmVudC5zdHJlYW1zICYmIHBlZXJfaWQpIHtcbiAgICAgICAgY29uc3QgdmlkZW9PYmogPSBnZXRWaWRlb09iaihwZWVyX2lkKVxuICAgICAgICBpZiAoIXZpZGVvT2JqKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2aWRlb09iai5zcmNPYmplY3QgPSBldmVudC5zdHJlYW1zWzBdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlbW90ZVBlZXJDb25uZWN0aW9ucyhuZXdTdHJlYW06IHsgZ2V0VmlkZW9UcmFja3M6ICgpID0+IGFueVtdOyB9KSB7XG4gICAgZm9yIChjb25zdCBwZWVySWQgaW4gX3BlZXJfbGlzdCkge1xuICAgICAgICBpZiAoX3BlZXJfbGlzdC5oYXNPd25Qcm9wZXJ0eShwZWVySWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IF9wZWVyX2xpc3RbcGVlcklkXTtcbiAgICAgICAgICAgIGNvbnN0IHNlbmRlcnMgPSBwZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCk7XG4gICAgICAgICAgICBzZW5kZXJzLmZvckVhY2goKHNlbmRlcjogeyB0cmFjazogeyBraW5kOiBzdHJpbmc7IH07IHJlcGxhY2VUcmFjazogKGFyZzA6IGFueSkgPT4gdm9pZDsgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZW5kZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXIucmVwbGFjZVRyYWNrKG5ld1N0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0iXSwibmFtZXMiOlsiYWRkVmlkZW9FbGVtZW50IiwiZ2V0VmlkZW9PYmoiLCJyZW1vdmVWaWRlb0VsZW1lbnQiLCJteUlEIiwiX3BlZXJfbGlzdCIsIm9uQ29ubmVjdCIsInNvY2tldCIsInJvb21JZCIsInJvb21OYW1lIiwiZGlzcGxheU5hbWUiLCJsYW5ndWFnZSIsImNvbnNvbGUiLCJsb2ciLCJlbWl0Iiwicm9vbV9pZCIsInJvb21fbmFtZSIsImRpc3BsYXlfbmFtZSIsIm9uVXNlckNvbm5lY3QiLCJkYXRhIiwicGVlcl9pZCIsInVuZGVmaW5lZCIsIm9uVXNlckRpc2Nvbm5lY3RlZCIsImNsb3NlQ29ubmVjdGlvbiIsIm9uVXNlckxpc3QiLCJteVZpZGVvIiwicmVjdmRfbGlzdCIsImhhc093blByb3BlcnR5IiwiZXgiLCJzdGFydF93ZWJydGMiLCJvbmljZWNhbmRpZGF0ZSIsIm9udHJhY2siLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwibG9nX3VzZXJfbGlzdCIsImtleSIsIlBDX0NPTkZJRyIsImljZVNlcnZlcnMiLCJ1cmxzIiwibG9nX2Vycm9yIiwiZSIsInNlbmRWaWFTZXJ2ZXIiLCJvbkRhdGEiLCJtc2ciLCJoYW5kbGVPZmZlck1zZyIsImhhbmRsZUFuc3dlck1zZyIsImhhbmRsZU5ld0lDRUNhbmRpZGF0ZU1zZyIsImludml0ZSIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwibG9jYWxfc3RyZWFtIiwic3JjT2JqZWN0IiwiTWVkaWFTdHJlYW0iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJhZGRUcmFjayIsImVycm9yIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJldmVudCIsImhhbmRsZUlDRUNhbmRpZGF0ZUV2ZW50IiwiaGFuZGxlVHJhY2tFdmVudCIsImhhbmRsZU5lZ290aWF0aW9uTmVlZGVkRXZlbnQiLCJjcmVhdGVPZmZlciIsInRoZW4iLCJvZmZlciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiY2F0Y2giLCJkZXNjIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJjcmVhdGVBbnN3ZXIiLCJhbnN3ZXIiLCJjYW5kaWRhdGUiLCJSVENJY2VDYW5kaWRhdGUiLCJhZGRJY2VDYW5kaWRhdGUiLCJzdHJlYW1zIiwidmlkZW9PYmoiLCJ1cGRhdGVSZW1vdGVQZWVyQ29ubmVjdGlvbnMiLCJuZXdTdHJlYW0iLCJwZWVySWQiLCJwZWVyQ29ubmVjdGlvbiIsInNlbmRlcnMiLCJnZXRTZW5kZXJzIiwic2VuZGVyIiwia2luZCIsInJlcGxhY2VUcmFjayIsImdldFZpZGVvVHJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/socketNetworkHandlers.ts\n"));

/***/ })

});