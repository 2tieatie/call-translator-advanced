"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/call/[roomId]/[roomName]/checkpoint/page",{

/***/ "(app-pages-browser)/./app/utils/socketNetworkHandlers.ts":
/*!********************************************!*\
  !*** ./app/utils/socketNetworkHandlers.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPeerConnection: function() { return /* binding */ createPeerConnection; },\n/* harmony export */   handleNegotiationNeededEvent: function() { return /* binding */ handleNegotiationNeededEvent; },\n/* harmony export */   invite: function() { return /* binding */ invite; },\n/* harmony export */   onConnect: function() { return /* binding */ onConnect; },\n/* harmony export */   onData: function() { return /* binding */ onData; },\n/* harmony export */   onUserConnect: function() { return /* binding */ onUserConnect; },\n/* harmony export */   onUserDisconnected: function() { return /* binding */ onUserDisconnected; },\n/* harmony export */   onUserList: function() { return /* binding */ onUserList; },\n/* harmony export */   sendViaServer: function() { return /* binding */ sendViaServer; },\n/* harmony export */   start_webrtc: function() { return /* binding */ start_webrtc; },\n/* harmony export */   updateRemotePeerConnections: function() { return /* binding */ updateRemotePeerConnections; }\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/utils */ \"(app-pages-browser)/./app/utils/utils.ts\");\n\nlet myID;\nlet _peer_list = {};\nconst onConnect = (socket, roomId, roomName, displayName, language)=>{\n    console.log(\"socket connected....\");\n    socket.emit(\"join-room\", {\n        room_id: roomId,\n        room_name: roomName,\n        display_name: displayName,\n        language: language\n    });\n};\nconst onUserConnect = (data)=>{\n    console.log(\"user-connect \", data);\n    let peer_id = data[\"sid\"];\n    let display_name = data[\"name\"];\n    _peer_list[peer_id] = undefined;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n};\nconst onUserDisconnected = (data)=>{\n    console.log(\"user-disconnect \", data);\n    let peer_id = data[\"sid\"];\n    closeConnection(peer_id);\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n};\nconst onUserList = (data, socket, myVideo)=>{\n    console.log(\"user list recvd \", data);\n    myID = data[\"my_id\"];\n    if (\"list\" in data) {\n        let recvd_list = data[\"list\"];\n        try {\n            for(const peer_id in _peer_list){\n                if (!recvd_list.hasOwnProperty(peer_id)) {\n                    closeConnection(peer_id);\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.removeVideoElement)(peer_id);\n                }\n            }\n        } catch (ex) {\n            console.log(ex);\n        }\n        // add existing users to user list\n        for(let peer_id in recvd_list){\n            let display_name = recvd_list[peer_id];\n            _peer_list[peer_id] = undefined;\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.addVideoElement)(peer_id, display_name);\n        }\n        start_webrtc(myVideo, socket);\n    }\n};\nconst closeConnection = (peer_id)=>{\n    if (peer_id in _peer_list) {\n        _peer_list[peer_id].onicecandidate = null;\n        _peer_list[peer_id].ontrack = null;\n        _peer_list[peer_id].onnegotiationneeded = null;\n        delete _peer_list[peer_id]; // remove user from user list\n    }\n};\nconst log_user_list = ()=>{\n    for(let key in _peer_list){\n        console.log(\"\".concat(key, \": \").concat(_peer_list[key]));\n    }\n};\n//---------------[ webrtc ]--------------------\nlet PC_CONFIG = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:stun1.l.google.com:19302\"\n            ]\n        }\n    ]\n};\nconst log_error = (e)=>{\n    console.log(\"[ERROR] \", e);\n};\nconst sendViaServer = (data, socket)=>{\n    socket.emit(\"data\", data);\n};\nconst onData = (msg, socket, myVideo)=>{\n    switch(msg[\"type\"]){\n        case \"offer\":\n            handleOfferMsg(msg, socket, myVideo);\n            break;\n        case \"answer\":\n            handleAnswerMsg(msg);\n            break;\n        case \"new-ice-candidate\":\n            handleNewICECandidateMsg(msg);\n            break;\n    }\n};\nconst start_webrtc = (myVideo, socket)=>{\n    // send offer to all other members\n    for(let peer_id in _peer_list){\n        invite(peer_id, myVideo, socket);\n    }\n};\nconst invite = (peer_id, myVideo, socket)=>{\n    if (_peer_list[peer_id]) {\n        console.log(\"[Not supposed to happen!] Attempting to start a connection that already exists!\");\n        return;\n    } else if (peer_id === myID) {\n        console.log(\"[Not supposed to happen!] Trying to connect to self!\");\n        return;\n    } else {\n        console.log(\"Creating peer connection for <\".concat(peer_id, \"> ...\"));\n        createPeerConnection(peer_id, socket);\n        let local_stream = myVideo === null || myVideo === void 0 ? void 0 : myVideo.srcObject;\n        if (local_stream && local_stream instanceof MediaStream) {\n            local_stream.getTracks().forEach((track)=>{\n                _peer_list[peer_id].addTrack(track, local_stream);\n            });\n        } else {\n            console.error(\"Local stream is null or not a MediaStream\");\n            console.log(myVideo);\n        }\n    }\n};\nconst createPeerConnection = (peer_id, socket)=>{\n    _peer_list[peer_id] = new RTCPeerConnection(PC_CONFIG);\n    _peer_list[peer_id].onicecandidate = (event)=>{\n        handleICECandidateEvent(event, peer_id, socket);\n    };\n    _peer_list[peer_id].ontrack = (event)=>{\n        handleTrackEvent(event, peer_id);\n    };\n    _peer_list[peer_id].onnegotiationneeded = ()=>{\n        handleNegotiationNeededEvent(peer_id, socket);\n    };\n};\nconst handleNegotiationNeededEvent = (peer_id, socket)=>{\n    _peer_list[peer_id].createOffer().then((offer)=>{\n        return _peer_list[peer_id].setLocalDescription(offer);\n    }).then(()=>{\n        console.log(\"sending offer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"offer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleOfferMsg = (msg, socket, myVideo)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"offer recieved from <\".concat(peer_id, \">\"));\n    createPeerConnection(peer_id, socket);\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc).then(()=>{\n        let local_stream = myVideo.srcObject;\n        local_stream.getTracks().forEach((track)=>{\n            try {\n                _peer_list[peer_id].addTrack(track, local_stream);\n            } catch (error) {\n                console.log(error);\n            }\n        });\n    }).then(()=>{\n        return _peer_list[peer_id].createAnswer();\n    }).then((answer)=>{\n        return _peer_list[peer_id].setLocalDescription(answer);\n    }).then(()=>{\n        console.log(\"sending answer to <\".concat(peer_id, \"> ...\"));\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"answer\",\n            \"sdp\": _peer_list[peer_id].localDescription\n        }, socket);\n    }).catch(log_error);\n};\nconst handleAnswerMsg = (msg)=>{\n    let peer_id = msg[\"sender_id\"];\n    console.log(\"answer recieved from <\".concat(peer_id, \">\"));\n    let desc = new RTCSessionDescription(msg[\"sdp\"]);\n    _peer_list[peer_id].setRemoteDescription(desc);\n};\nconst handleICECandidateEvent = (event, peer_id, socket)=>{\n    if (event.candidate) {\n        sendViaServer({\n            \"sender_id\": myID,\n            \"target_id\": peer_id,\n            \"type\": \"new-ice-candidate\",\n            \"candidate\": event.candidate\n        }, socket);\n    }\n};\nconst handleNewICECandidateMsg = (msg)=>{\n    let peer_id;\n    console.log(\"ICE candidate recieved from <\".concat(peer_id, \">\"));\n    let candidate = new RTCIceCandidate(msg.candidate);\n    _peer_list[msg[\"sender_id\"]].addIceCandidate(candidate).catch(log_error);\n};\nconst handleTrackEvent = (event, peer_id)=>{\n    console.log(\"track event recieved from <\".concat(peer_id, \">\"));\n    if (event.streams && peer_id) {\n        const videoObj = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.getVideoObj)(peer_id);\n        if (!videoObj) {\n            return;\n        }\n        videoObj.srcObject = event.streams[0];\n    }\n};\nfunction updateRemotePeerConnections(newStream) {\n    for(const peerId in _peer_list){\n        if (_peer_list.hasOwnProperty(peerId)) {\n            const peerConnection = _peer_list[peerId];\n            const senders = peerConnection.getSenders();\n            senders.forEach((sender)=>{\n                if (sender.track.kind === \"video\") {\n                    sender.replaceTrack(newStream.getVideoTracks()[0]);\n                }\n            });\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9zb2NrZXROZXR3b3JrSGFuZGxlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStFO0FBRS9FLElBQUlHO0FBQ0osSUFBSUMsYUFBa0IsQ0FBQztBQUVoQixNQUFNQyxZQUFZLENBQUNDLFFBQWFDLFFBQWFDLFVBQWVDLGFBQWtCQztJQUNqRkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1pOLE9BQU9PLElBQUksQ0FBQyxhQUFhO1FBQUNDLFNBQVNQO1FBQVFRLFdBQVdQO1FBQVVRLGNBQWNQO1FBQWFDLFVBQVVBO0lBQVE7QUFDakgsRUFBQztBQUVNLE1BQU1PLGdCQUFnQixDQUFDQztJQUMxQlAsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQk07SUFDN0IsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekIsSUFBSUYsZUFBZUUsSUFBSSxDQUFDLE9BQU87SUFDL0JkLFVBQVUsQ0FBQ2UsUUFBUSxHQUFHQztJQUN0QnBCLDZEQUFlQSxDQUFDbUIsU0FBU0g7QUFDN0IsRUFBQztBQUNNLE1BQU1LLHFCQUFxQixDQUFDSDtJQUMvQlAsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQk07SUFDaEMsSUFBSUMsVUFBVUQsSUFBSSxDQUFDLE1BQU07SUFDekJJLGdCQUFnQkg7SUFDaEJqQixnRUFBa0JBLENBQUNpQjtBQUN2QixFQUFDO0FBRU0sTUFBTUksYUFBYSxDQUFDTCxNQUFXWixRQUFha0I7SUFDL0NiLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JNO0lBQ2hDZixPQUFPZSxJQUFJLENBQUMsUUFBUTtJQUVwQixJQUFJLFVBQVVBLE1BQ2Q7UUFDSSxJQUFJTyxhQUFhUCxJQUFJLENBQUMsT0FBTztRQUM3QixJQUFJO1lBQ0EsSUFBSyxNQUFNQyxXQUFXZixXQUFZO2dCQUM5QixJQUFJLENBQUNxQixXQUFXQyxjQUFjLENBQUNQLFVBQVU7b0JBQ3JDRyxnQkFBZ0JIO29CQUNoQmpCLGdFQUFrQkEsQ0FBQ2lC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RyxDQUFDLDhCQUFzQyxPQUFSTyxTQUFRO0lBRWxELElBQUlxQyxNQUFNa0IsT0FBTyxJQUFJdkQsU0FBUztRQUMxQixNQUFNd0QsV0FBVzFFLHlEQUFXQSxDQUFDa0I7UUFDN0IsSUFBSSxDQUFDd0QsVUFBVTtZQUNYO1FBQ0o7UUFDQUEsU0FBUzNCLFNBQVMsR0FBR1EsTUFBTWtCLE9BQU8sQ0FBQyxFQUFFO0lBQ3pDO0FBQ0o7QUFFTyxTQUFTRSw0QkFBNEJDLFNBQTJDO0lBQ25GLElBQUssTUFBTUMsVUFBVTFFLFdBQVk7UUFDN0IsSUFBSUEsV0FBV3NCLGNBQWMsQ0FBQ29ELFNBQVM7WUFDbkMsTUFBTUMsaUJBQWlCM0UsVUFBVSxDQUFDMEUsT0FBTztZQUN6QyxNQUFNRSxVQUFVRCxlQUFlRSxVQUFVO1lBQ3pDRCxRQUFRN0IsT0FBTyxDQUFDLENBQUMrQjtnQkFDYixJQUFJQSxPQUFPOUIsS0FBSyxDQUFDK0IsSUFBSSxLQUFLLFNBQVM7b0JBQy9CRCxPQUFPRSxZQUFZLENBQUNQLFVBQVVRLGNBQWMsRUFBRSxDQUFDLEVBQUU7Z0JBQ3JEO1lBQ0o7UUFDSjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3V0aWxzL3NvY2tldE5ldHdvcmtIYW5kbGVycy50cz8xYzcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YWRkVmlkZW9FbGVtZW50LCBnZXRWaWRlb09iaiwgcmVtb3ZlVmlkZW9FbGVtZW50fSBmcm9tIFwiQC91dGlscy91dGlsc1wiO1xuXG5sZXQgbXlJRDogYW55O1xubGV0IF9wZWVyX2xpc3Q6IGFueSA9IHt9XG5cbmV4cG9ydCBjb25zdCBvbkNvbm5lY3QgPSAoc29ja2V0OiBhbnksIHJvb21JZDogYW55LCByb29tTmFtZTogYW55LCBkaXNwbGF5TmFtZTogYW55LCBsYW5ndWFnZTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJzb2NrZXQgY29ubmVjdGVkLi4uLlwiKTtcbiAgICBzb2NrZXQuZW1pdChcImpvaW4tcm9vbVwiLCB7cm9vbV9pZDogcm9vbUlkLCByb29tX25hbWU6IHJvb21OYW1lLCBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lLCBsYW5ndWFnZTogbGFuZ3VhZ2V9KTtcbn1cblxuZXhwb3J0IGNvbnN0IG9uVXNlckNvbm5lY3QgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJ1c2VyLWNvbm5lY3QgXCIsIGRhdGEpO1xuICAgIGxldCBwZWVyX2lkID0gZGF0YVtcInNpZFwiXTtcbiAgICBsZXQgZGlzcGxheV9uYW1lID0gZGF0YVtcIm5hbWVcIl07XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXSA9IHVuZGVmaW5lZDtcbiAgICBhZGRWaWRlb0VsZW1lbnQocGVlcl9pZCwgZGlzcGxheV9uYW1lKTtcbn1cbmV4cG9ydCBjb25zdCBvblVzZXJEaXNjb25uZWN0ZWQgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJ1c2VyLWRpc2Nvbm5lY3QgXCIsIGRhdGEpO1xuICAgIGxldCBwZWVyX2lkID0gZGF0YVtcInNpZFwiXTtcbiAgICBjbG9zZUNvbm5lY3Rpb24ocGVlcl9pZCk7XG4gICAgcmVtb3ZlVmlkZW9FbGVtZW50KHBlZXJfaWQpO1xufVxuXG5leHBvcnQgY29uc3Qgb25Vc2VyTGlzdCA9IChkYXRhOiBhbnksIHNvY2tldDogYW55LCBteVZpZGVvOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcInVzZXIgbGlzdCByZWN2ZCBcIiwgZGF0YSk7XG4gICAgbXlJRCA9IGRhdGFbXCJteV9pZFwiXTtcblxuICAgIGlmKCBcImxpc3RcIiBpbiBkYXRhKSAvLyBub3QgdGhlIGZpcnN0IHRvIGNvbm5lY3QgdG8gcm9vbSwgZXhpc3RpbmcgdXNlciBsaXN0IHJlY2lldmVkXG4gICAge1xuICAgICAgICBsZXQgcmVjdmRfbGlzdCA9IGRhdGFbXCJsaXN0XCJdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwZWVyX2lkIGluIF9wZWVyX2xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY3ZkX2xpc3QuaGFzT3duUHJvcGVydHkocGVlcl9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKHBlZXJfaWQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVWaWRlb0VsZW1lbnQocGVlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgZXhpc3RpbmcgdXNlcnMgdG8gdXNlciBsaXN0XG4gICAgICAgIGZvcihsZXQgcGVlcl9pZCBpbiByZWN2ZF9saXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZGlzcGxheV9uYW1lID0gcmVjdmRfbGlzdFtwZWVyX2lkXTtcbiAgICAgICAgICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZGRWaWRlb0VsZW1lbnQocGVlcl9pZCwgZGlzcGxheV9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydF93ZWJydGMobXlWaWRlbywgc29ja2V0KTtcbiAgICB9XG59XG5cbmNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChwZWVyX2lkOiBzdHJpbmcpID0+IHtcbiAgICBpZihwZWVyX2lkIGluIF9wZWVyX2xpc3QpXG4gICAge1xuICAgICAgICBfcGVlcl9saXN0W3BlZXJfaWRdLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbnRyYWNrID0gbnVsbDtcbiAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcblxuICAgICAgICBkZWxldGUgX3BlZXJfbGlzdFtwZWVyX2lkXTsgLy8gcmVtb3ZlIHVzZXIgZnJvbSB1c2VyIGxpc3RcbiAgICB9XG59XG5cbmNvbnN0IGxvZ191c2VyX2xpc3QgPSAoKSA9PiB7XG4gICAgZm9yKGxldCBrZXkgaW4gX3BlZXJfbGlzdClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke2tleX06ICR7X3BlZXJfbGlzdFtrZXldfWApO1xuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS1bIHdlYnJ0YyBdLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IFBDX0NPTkZJRyA9IHtcbiAgICBpY2VTZXJ2ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6IFtcbiAgICAgICAgICAgICAgICAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicsXG4gICAgICAgICAgICAgICAgJ3N0dW46c3R1bjEubC5nb29nbGUuY29tOjE5MzAyJyxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgXVxufTtcblxuY29uc3QgbG9nX2Vycm9yID0gKGU6IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiW0VSUk9SXSBcIiwgZSk7XG59XG5cbmV4cG9ydCBjb25zdCBzZW5kVmlhU2VydmVyID0gKGRhdGE6IGFueSwgc29ja2V0OiBhbnkpID0+IHtcbiAgICBzb2NrZXQuZW1pdChcImRhdGFcIiwgZGF0YSk7XG59XG5cbmV4cG9ydCBjb25zdCBvbkRhdGEgPSAobXNnOiBhbnksIHNvY2tldDogYW55LCBteVZpZGVvOiBhbnkpID0+IHtcbiAgICBzd2l0Y2gobXNnW1widHlwZVwiXSlcbiAgICB7XG4gICAgICAgIGNhc2UgXCJvZmZlclwiOlxuICAgICAgICAgICAgaGFuZGxlT2ZmZXJNc2cobXNnLCBzb2NrZXQsIG15VmlkZW8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbnN3ZXJcIjpcbiAgICAgICAgICAgIGhhbmRsZUFuc3dlck1zZyhtc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXctaWNlLWNhbmRpZGF0ZVwiOlxuICAgICAgICAgICAgaGFuZGxlTmV3SUNFQ2FuZGlkYXRlTXNnKG1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdGFydF93ZWJydGMgPSAobXlWaWRlbzogYW55LCBzb2NrZXQ6IGFueSkgPT4ge1xuICAgIC8vIHNlbmQgb2ZmZXIgdG8gYWxsIG90aGVyIG1lbWJlcnNcbiAgICBmb3IobGV0IHBlZXJfaWQgaW4gX3BlZXJfbGlzdClcbiAgICB7XG4gICAgICAgIGludml0ZShwZWVyX2lkLCBteVZpZGVvLCBzb2NrZXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGludml0ZSA9IChwZWVyX2lkOiBzdHJpbmcsIG15VmlkZW86IGFueSwgc29ja2V0OiBhbnkpID0+IHtcbiAgICBpZiAoX3BlZXJfbGlzdFtwZWVyX2lkXSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltOb3Qgc3VwcG9zZWQgdG8gaGFwcGVuIV0gQXR0ZW1wdGluZyB0byBzdGFydCBhIGNvbm5lY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyFcIilcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsc2UgaWYgKHBlZXJfaWQgPT09IG15SUQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbTm90IHN1cHBvc2VkIHRvIGhhcHBlbiFdIFRyeWluZyB0byBjb25uZWN0IHRvIHNlbGYhXCIpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coYENyZWF0aW5nIHBlZXIgY29ubmVjdGlvbiBmb3IgPCR7cGVlcl9pZH0+IC4uLmApO1xuICAgICAgICBjcmVhdGVQZWVyQ29ubmVjdGlvbihwZWVyX2lkLCBzb2NrZXQpO1xuXG4gICAgICBsZXQgbG9jYWxfc3RyZWFtID0gbXlWaWRlbz8uc3JjT2JqZWN0O1xuICAgICAgaWYgKGxvY2FsX3N0cmVhbSAmJiBsb2NhbF9zdHJlYW0gaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgICAgICBsb2NhbF9zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2s6IGFueSk9PntfcGVlcl9saXN0W3BlZXJfaWRdLmFkZFRyYWNrKHRyYWNrLCBsb2NhbF9zdHJlYW0pO30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTG9jYWwgc3RyZWFtIGlzIG51bGwgb3Igbm90IGEgTWVkaWFTdHJlYW0nKTtcbiAgICAgICAgY29uc29sZS5sb2cobXlWaWRlbylcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQZWVyQ29ubmVjdGlvbiA9IChwZWVyX2lkOiBzdHJpbmcsIHNvY2tldDogYW55KSA9PiB7XG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXSA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihQQ19DT05GSUcpO1xuXG4gICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5vbmljZWNhbmRpZGF0ZSA9IChldmVudDogYW55KSA9PiB7aGFuZGxlSUNFQ2FuZGlkYXRlRXZlbnQoZXZlbnQsIHBlZXJfaWQsIHNvY2tldCl9O1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub250cmFjayA9IChldmVudDogYW55KSA9PiB7aGFuZGxlVHJhY2tFdmVudChldmVudCwgcGVlcl9pZCl9O1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0ub25uZWdvdGlhdGlvbm5lZWRlZCA9ICgpID0+IHtoYW5kbGVOZWdvdGlhdGlvbk5lZWRlZEV2ZW50KHBlZXJfaWQsIHNvY2tldCl9O1xufVxuXG5cbmV4cG9ydCBjb25zdCBoYW5kbGVOZWdvdGlhdGlvbk5lZWRlZEV2ZW50ID0gKHBlZXJfaWQ6IHN0cmluZywgc29ja2V0OiBhbnkpID0+IHtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLmNyZWF0ZU9mZmVyKClcbiAgICAudGhlbigob2ZmZXI6IGFueSk9PntyZXR1cm4gX3BlZXJfbGlzdFtwZWVyX2lkXS5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTt9KVxuICAgIC50aGVuKCgpPT57XG4gICAgICAgIGNvbnNvbGUubG9nKGBzZW5kaW5nIG9mZmVyIHRvIDwke3BlZXJfaWR9PiAuLi5gKTtcbiAgICAgICAgc2VuZFZpYVNlcnZlcih7XG4gICAgICAgICAgICBcInNlbmRlcl9pZFwiOiBteUlELFxuICAgICAgICAgICAgXCJ0YXJnZXRfaWRcIjogcGVlcl9pZCxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9mZmVyXCIsXG4gICAgICAgICAgICBcInNkcFwiOiBfcGVlcl9saXN0W3BlZXJfaWRdLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgICAgfSwgc29ja2V0KTtcbiAgICB9KVxuICAgIC5jYXRjaChsb2dfZXJyb3IpO1xufVxuXG5cbmNvbnN0IGhhbmRsZU9mZmVyTXNnID0gKG1zZzogYW55LCBzb2NrZXQ6IGFueSwgbXlWaWRlbzogYW55KSA9PiB7XG4gICAgbGV0IHBlZXJfaWQgPSBtc2dbJ3NlbmRlcl9pZCddO1xuXG4gICAgY29uc29sZS5sb2coYG9mZmVyIHJlY2lldmVkIGZyb20gPCR7cGVlcl9pZH0+YCk7XG5cbiAgICBjcmVhdGVQZWVyQ29ubmVjdGlvbihwZWVyX2lkLCBzb2NrZXQpO1xuICAgIGxldCBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihtc2dbJ3NkcCddKTtcbiAgICBfcGVlcl9saXN0W3BlZXJfaWRdLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpXG4gICAgLnRoZW4oKCk9PntcbiAgICAgICAgbGV0IGxvY2FsX3N0cmVhbSA9IG15VmlkZW8uc3JjT2JqZWN0O1xuICAgICAgICBsb2NhbF9zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2s6IGFueSk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BlZXJfbGlzdFtwZWVyX2lkXS5hZGRUcmFjayh0cmFjaywgbG9jYWxfc3RyZWFtKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbigoKT0+e3JldHVybiBfcGVlcl9saXN0W3BlZXJfaWRdLmNyZWF0ZUFuc3dlcigpO30pXG4gICAgLnRoZW4oKGFuc3dlcjogYW55KT0+e3JldHVybiBfcGVlcl9saXN0W3BlZXJfaWRdLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTt9KVxuICAgIC50aGVuKCgpPT57XG4gICAgICAgIGNvbnNvbGUubG9nKGBzZW5kaW5nIGFuc3dlciB0byA8JHtwZWVyX2lkfT4gLi4uYCk7XG4gICAgICAgIHNlbmRWaWFTZXJ2ZXIoe1xuICAgICAgICAgICAgXCJzZW5kZXJfaWRcIjogbXlJRCxcbiAgICAgICAgICAgIFwidGFyZ2V0X2lkXCI6IHBlZXJfaWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhbnN3ZXJcIixcbiAgICAgICAgICAgIFwic2RwXCI6IF9wZWVyX2xpc3RbcGVlcl9pZF0ubG9jYWxEZXNjcmlwdGlvblxuICAgICAgICB9LCBzb2NrZXQpO1xuICAgIH0pXG4gICAgLmNhdGNoKGxvZ19lcnJvcik7XG59XG5cbmNvbnN0IGhhbmRsZUFuc3dlck1zZyA9IChtc2c6IGFueSkgPT4ge1xuICAgIGxldCBwZWVyX2lkID0gbXNnWydzZW5kZXJfaWQnXTtcbiAgICBjb25zb2xlLmxvZyhgYW5zd2VyIHJlY2lldmVkIGZyb20gPCR7cGVlcl9pZH0+YCk7XG4gICAgbGV0IGRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZ1snc2RwJ10pO1xuICAgIF9wZWVyX2xpc3RbcGVlcl9pZF0uc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYylcbn1cblxuXG5jb25zdCBoYW5kbGVJQ0VDYW5kaWRhdGVFdmVudCA9IChldmVudDogeyBjYW5kaWRhdGU6IGFueTsgfSwgcGVlcl9pZDogc3RyaW5nLCBzb2NrZXQ6IGFueSkgPT4ge1xuICAgIGlmKGV2ZW50LmNhbmRpZGF0ZSl7XG4gICAgICAgIHNlbmRWaWFTZXJ2ZXIoe1xuICAgICAgICAgICAgXCJzZW5kZXJfaWRcIjogbXlJRCxcbiAgICAgICAgICAgIFwidGFyZ2V0X2lkXCI6IHBlZXJfaWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJuZXctaWNlLWNhbmRpZGF0ZVwiLFxuICAgICAgICAgICAgXCJjYW5kaWRhdGVcIjogZXZlbnQuY2FuZGlkYXRlXG4gICAgICAgIH0sIHNvY2tldCk7XG4gICAgfVxufVxuXG5jb25zdCBoYW5kbGVOZXdJQ0VDYW5kaWRhdGVNc2cgPSAobXNnOiBhbnkpID0+IHtcbiAgICBsZXQgcGVlcl9pZDtcbiAgICBjb25zb2xlLmxvZyhgSUNFIGNhbmRpZGF0ZSByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuICAgIGxldCBjYW5kaWRhdGUgPSBuZXcgUlRDSWNlQ2FuZGlkYXRlKG1zZy5jYW5kaWRhdGUpO1xuICAgIF9wZWVyX2xpc3RbbXNnW1wic2VuZGVyX2lkXCJdXS5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgIC5jYXRjaChsb2dfZXJyb3IpO1xufVxuXG5cbmNvbnN0IGhhbmRsZVRyYWNrRXZlbnQgPSAoZXZlbnQ6IGFueSwgcGVlcl9pZDogc3RyaW5nKSA9Plxue1xuICAgIGNvbnNvbGUubG9nKGB0cmFjayBldmVudCByZWNpZXZlZCBmcm9tIDwke3BlZXJfaWR9PmApO1xuXG4gICAgaWYgKGV2ZW50LnN0cmVhbXMgJiYgcGVlcl9pZCkge1xuICAgICAgICBjb25zdCB2aWRlb09iaiA9IGdldFZpZGVvT2JqKHBlZXJfaWQpXG4gICAgICAgIGlmICghdmlkZW9PYmopIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZpZGVvT2JqLnNyY09iamVjdCA9IGV2ZW50LnN0cmVhbXNbMF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUmVtb3RlUGVlckNvbm5lY3Rpb25zKG5ld1N0cmVhbTogeyBnZXRWaWRlb1RyYWNrczogKCkgPT4gYW55W107IH0pIHtcbiAgICBmb3IgKGNvbnN0IHBlZXJJZCBpbiBfcGVlcl9saXN0KSB7XG4gICAgICAgIGlmIChfcGVlcl9saXN0Lmhhc093blByb3BlcnR5KHBlZXJJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gX3BlZXJfbGlzdFtwZWVySWRdO1xuICAgICAgICAgICAgY29uc3Qgc2VuZGVycyA9IHBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMoKTtcbiAgICAgICAgICAgIHNlbmRlcnMuZm9yRWFjaCgoc2VuZGVyOiB7IHRyYWNrOiB7IGtpbmQ6IHN0cmluZzsgfTsgcmVwbGFjZVRyYWNrOiAoYXJnMDogYW55KSA9PiB2b2lkOyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlci50cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobmV3U3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSJdLCJuYW1lcyI6WyJhZGRWaWRlb0VsZW1lbnQiLCJnZXRWaWRlb09iaiIsInJlbW92ZVZpZGVvRWxlbWVudCIsIm15SUQiLCJfcGVlcl9saXN0Iiwib25Db25uZWN0Iiwic29ja2V0Iiwicm9vbUlkIiwicm9vbU5hbWUiLCJkaXNwbGF5TmFtZSIsImxhbmd1YWdlIiwiY29uc29sZSIsImxvZyIsImVtaXQiLCJyb29tX2lkIiwicm9vbV9uYW1lIiwiZGlzcGxheV9uYW1lIiwib25Vc2VyQ29ubmVjdCIsImRhdGEiLCJwZWVyX2lkIiwidW5kZWZpbmVkIiwib25Vc2VyRGlzY29ubmVjdGVkIiwiY2xvc2VDb25uZWN0aW9uIiwib25Vc2VyTGlzdCIsIm15VmlkZW8iLCJyZWN2ZF9saXN0IiwiaGFzT3duUHJvcGVydHkiLCJleCIsInN0YXJ0X3dlYnJ0YyIsIm9uaWNlY2FuZGlkYXRlIiwib250cmFjayIsIm9ubmVnb3RpYXRpb25uZWVkZWQiLCJsb2dfdXNlcl9saXN0Iiwia2V5IiwiUENfQ09ORklHIiwiaWNlU2VydmVycyIsInVybHMiLCJsb2dfZXJyb3IiLCJlIiwic2VuZFZpYVNlcnZlciIsIm9uRGF0YSIsIm1zZyIsImhhbmRsZU9mZmVyTXNnIiwiaGFuZGxlQW5zd2VyTXNnIiwiaGFuZGxlTmV3SUNFQ2FuZGlkYXRlTXNnIiwiaW52aXRlIiwiY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJsb2NhbF9zdHJlYW0iLCJzcmNPYmplY3QiLCJNZWRpYVN0cmVhbSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImFkZFRyYWNrIiwiZXJyb3IiLCJSVENQZWVyQ29ubmVjdGlvbiIsImV2ZW50IiwiaGFuZGxlSUNFQ2FuZGlkYXRlRXZlbnQiLCJoYW5kbGVUcmFja0V2ZW50IiwiaGFuZGxlTmVnb3RpYXRpb25OZWVkZWRFdmVudCIsImNyZWF0ZU9mZmVyIiwidGhlbiIsIm9mZmVyIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsImxvY2FsRGVzY3JpcHRpb24iLCJjYXRjaCIsImRlc2MiLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImNyZWF0ZUFuc3dlciIsImFuc3dlciIsImNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsImFkZEljZUNhbmRpZGF0ZSIsInN0cmVhbXMiLCJ2aWRlb09iaiIsInVwZGF0ZVJlbW90ZVBlZXJDb25uZWN0aW9ucyIsIm5ld1N0cmVhbSIsInBlZXJJZCIsInBlZXJDb25uZWN0aW9uIiwic2VuZGVycyIsImdldFNlbmRlcnMiLCJzZW5kZXIiLCJraW5kIiwicmVwbGFjZVRyYWNrIiwiZ2V0VmlkZW9UcmFja3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/socketNetworkHandlers.ts\n"));

/***/ })

});